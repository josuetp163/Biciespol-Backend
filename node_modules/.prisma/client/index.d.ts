
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';

export import DMMF = runtime.DMMF

/**
 * Prisma Errors
 */
export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
export import PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export import sql = runtime.sqltag
export import empty = runtime.empty
export import join = runtime.join
export import raw = runtime.raw
export import Sql = runtime.Sql

/**
 * Decimal.js
 */
export import Decimal = runtime.Decimal

/**
 * Prisma Client JS version: 2.14.0
 * Query Engine version: 5d491261d382a2a5ffdc71de17072b0e409f1cc1
 */
export type PrismaVersion = {
  client: string
}

export const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export type InputJsonObject = {[Key in string]?: JsonValue}
 
export interface InputJsonArray extends Array<JsonValue> {}
 
export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
 type SelectAndInclude = {
  select: any
  include: any
}
type HasSelect = {
  select: any
}
type HasInclude = {
  include: any
}
type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Buffer
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

export type Union = any

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

/**
A [[Boolean]]
*/
export type Boolean = True | False

// /**
// 1
// */
export type True = 1

/**
0
*/
export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never



/**
 * Used by group by
 */

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
> = IsObject<T> extends True ? U : T

type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but with an array
 */
type PickArray<T, K extends Array<keyof T>> = Pick<T, TupleToUnion<K>>





/**
 * Model Usuario
 */

export type Usuario = {
  idUsuario: number
  usuario: string
  pass: string
  matricula: number
}

/**
 * Model Estacion
 */

export type Estacion = {
  idEstacion: number
  nombre: string
}

/**
 * Model Bicicleta
 */

export type Bicicleta = {
  idBicicleta: number
  estado: string
  estacion: number
}

/**
 * Model Alquiler
 */

export type Alquiler = {
  idAlquiler: number
  usuario: number
  bicicleta: number
  fecha: Date
  estado: boolean
}

/**
 * Model Reportar
 */

export type Reportar = {
  idReportar: number
  usuario: number
  bicicleta: number
  contenido: string | null
  fecha: Date
  estado: boolean
}

/**
 * Model Foro
 */

export type Foro = {
  idForo: number
  descripcion: string | null
}

/**
 * Model Informacion
 */

export type Informacion = {
  idInformacion: number
  titulo: string
  contenido: string | null
  foro: number
}

/**
 * Model Publicacion
 */

export type Publicacion = {
  idPublicacion: number
  fecha: Date
  contenido: string | null
  foro: number
  usuario: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): Promise<T>;

  /**
   * Execute queries in a transaction
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   */
  $transaction: PromiseConstructor['all']

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate;

  /**
   * `prisma.estacion`: Exposes CRUD operations for the **Estacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estacions
    * const estacions = await prisma.estacion.findMany()
    * ```
    */
  get estacion(): Prisma.EstacionDelegate;

  /**
   * `prisma.bicicleta`: Exposes CRUD operations for the **Bicicleta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bicicletas
    * const bicicletas = await prisma.bicicleta.findMany()
    * ```
    */
  get bicicleta(): Prisma.BicicletaDelegate;

  /**
   * `prisma.alquiler`: Exposes CRUD operations for the **Alquiler** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alquilers
    * const alquilers = await prisma.alquiler.findMany()
    * ```
    */
  get alquiler(): Prisma.AlquilerDelegate;

  /**
   * `prisma.reportar`: Exposes CRUD operations for the **Reportar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reportars
    * const reportars = await prisma.reportar.findMany()
    * ```
    */
  get reportar(): Prisma.ReportarDelegate;

  /**
   * `prisma.foro`: Exposes CRUD operations for the **Foro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foros
    * const foros = await prisma.foro.findMany()
    * ```
    */
  get foro(): Prisma.ForoDelegate;

  /**
   * `prisma.informacion`: Exposes CRUD operations for the **Informacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Informacions
    * const informacions = await prisma.informacion.findMany()
    * ```
    */
  get informacion(): Prisma.InformacionDelegate;

  /**
   * `prisma.publicacion`: Exposes CRUD operations for the **Publicacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publicacions
    * const publicacions = await prisma.publicacion.findMany()
    * ```
    */
  get publicacion(): Prisma.PublicacionDelegate;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.14.0
   * Query Engine version: 5d491261d382a2a5ffdc71de17072b0e409f1cc1
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Usuario: 'Usuario',
    Estacion: 'Estacion',
    Bicicleta: 'Bicicleta',
    Alquiler: 'Alquiler',
    Reportar: 'Reportar',
    Foro: 'Foro',
    Informacion: 'Informacion',
    Publicacion: 'Publicacion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model Usuario
   */


  export type AggregateUsuario = {
    count: number | null
    avg: UsuarioAvgAggregateOutputType | null
    sum: UsuarioSumAggregateOutputType | null
    min: UsuarioMinAggregateOutputType | null
    max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    idUsuario: number
    matricula: number
  }

  export type UsuarioSumAggregateOutputType = {
    idUsuario: number
    matricula: number
  }

  export type UsuarioMinAggregateOutputType = {
    idUsuario: number
    usuario: string | null
    pass: string | null
    matricula: number
  }

  export type UsuarioMaxAggregateOutputType = {
    idUsuario: number
    usuario: string | null
    pass: string | null
    matricula: number
  }

  export type UsuarioCountAggregateOutputType = {
    idUsuario: number
    usuario: number | null
    pass: number | null
    matricula: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    idUsuario?: true
    matricula?: true
  }

  export type UsuarioSumAggregateInputType = {
    idUsuario?: true
    matricula?: true
  }

  export type UsuarioMinAggregateInputType = {
    idUsuario?: true
    usuario?: true
    pass?: true
    matricula?: true
  }

  export type UsuarioMaxAggregateInputType = {
    idUsuario?: true
    usuario?: true
    pass?: true
    matricula?: true
  }

  export type UsuarioCountAggregateInputType = {
    idUsuario?: true
    usuario?: true
    pass?: true
    matricula?: true
    _all?: true
  }

  export type AggregateUsuarioArgs = {
    /**
     * Filter which Usuario to aggregate.
    **/
    where?: UsuarioWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Usuarios to fetch.
    **/
    orderBy?: Enumerable<UsuarioOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    count?: true
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends AggregateUsuarioArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetUsuarioAggregateScalarType<T[P]>
  }

  export type GetUsuarioAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof UsuarioAvgAggregateOutputType ? UsuarioAvgAggregateOutputType[P] : never
  }

    



  export type UsuarioSelect = {
    idUsuario?: boolean
    usuario?: boolean
    pass?: boolean
    matricula?: boolean
    Alquiler?: boolean | FindManyAlquilerArgs
    Reportar?: boolean | FindManyReportarArgs
    Publicacion?: boolean | FindManyPublicacionArgs
  }

  export type UsuarioInclude = {
    Alquiler?: boolean | FindManyAlquilerArgs
    Reportar?: boolean | FindManyReportarArgs
    Publicacion?: boolean | FindManyPublicacionArgs
  }

  export type UsuarioGetPayload<
    S extends boolean | null | undefined | UsuarioArgs,
    U = keyof S
      > = S extends true
        ? Usuario
    : S extends undefined
    ? never
    : S extends UsuarioArgs | FindManyUsuarioArgs
    ?'include' extends U
    ? Usuario  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Alquiler'
        ? Array < AlquilerGetPayload<S['include'][P]>>  :
        P extends 'Reportar'
        ? Array < ReportarGetPayload<S['include'][P]>>  :
        P extends 'Publicacion'
        ? Array < PublicacionGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Usuario ?Usuario [P]
  : 
          P extends 'Alquiler'
        ? Array < AlquilerGetPayload<S['select'][P]>>  :
        P extends 'Reportar'
        ? Array < ReportarGetPayload<S['select'][P]>>  :
        P extends 'Publicacion'
        ? Array < PublicacionGetPayload<S['select'][P]>>  : never
  } 
    : Usuario
  : Usuario


  export interface UsuarioDelegate {
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {FindUniqueUsuarioArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueUsuarioArgs>(
      args: Subset<T, FindUniqueUsuarioArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario | null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | null>>

    /**
     * Find the first Usuario that matches the filter.
     * @param {FindFirstUsuarioArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstUsuarioArgs>(
      args?: Subset<T, FindFirstUsuarioArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario | null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | null>>

    /**
     * Find zero or more Usuarios that matches the filter.
     * @param {FindManyUsuarioArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `idUsuario`
     * const usuarioWithIdUsuarioOnly = await prisma.usuario.findMany({ select: { idUsuario: true } })
     * 
    **/
    findMany<T extends FindManyUsuarioArgs>(
      args?: Subset<T, FindManyUsuarioArgs>
    ): CheckSelect<T, Promise<Array<Usuario>>, Promise<Array<UsuarioGetPayload<T>>>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends UsuarioCreateArgs>(
      args: Subset<T, UsuarioCreateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends UsuarioDeleteArgs>(
      args: Subset<T, UsuarioDeleteArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuarioUpdateArgs>(
      args: Subset<T, UsuarioUpdateArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuarioDeleteManyArgs>(
      args?: Subset<T, UsuarioDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuarioUpdateManyArgs>(
      args: Subset<T, UsuarioUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends UsuarioUpsertArgs>(
      args: Subset<T, UsuarioUpsertArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario>, Prisma__UsuarioClient<UsuarioGetPayload<T>>>

    /**
     * Find zero or one Usuario that matches the filter.
     * @param {FindUniqueUsuarioArgs} args - Arguments to find a Usuario
     * @deprecated This will be deprecated please use prisma.usuario.findUnique
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueUsuarioArgs>(
      args: Subset<T, FindUniqueUsuarioArgs>
    ): CheckSelect<T, Prisma__UsuarioClient<Usuario | null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | null>>

    /**
     * Count the number of Usuarios.
     * @param {FindManyUsuarioArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count(args?: Omit<FindManyUsuarioArgs, 'select' | 'include'>): Promise<number>

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * @param {AggregateUsuarioArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregateUsuarioArgs>(args: Subset<T, AggregateUsuarioArgs>): Promise<GetUsuarioAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsuarioClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Alquiler<T extends FindManyAlquilerArgs = {}>(args?: Subset<T, FindManyAlquilerArgs>): CheckSelect<T, Promise<Array<Alquiler>>, Promise<Array<AlquilerGetPayload<T>>>>;

    Reportar<T extends FindManyReportarArgs = {}>(args?: Subset<T, FindManyReportarArgs>): CheckSelect<T, Promise<Array<Reportar>>, Promise<Array<ReportarGetPayload<T>>>>;

    Publicacion<T extends FindManyPublicacionArgs = {}>(args?: Subset<T, FindManyPublicacionArgs>): CheckSelect<T, Promise<Array<Publicacion>>, Promise<Array<PublicacionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Usuario findUnique
   */
  export type FindUniqueUsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario findFirst
   */
  export type FindFirstUsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuario to fetch.
    **/
    where?: UsuarioWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Usuarios to fetch.
    **/
    orderBy?: Enumerable<UsuarioOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Usuarios.
    **/
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario findMany
   */
  export type FindManyUsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsuarioInclude | null
    /**
     * Filter, which Usuarios to fetch.
    **/
    where?: UsuarioWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Usuarios to fetch.
    **/
    orderBy?: Enumerable<UsuarioOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
    **/
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
    **/
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * Usuario create
   */
  export type UsuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsuarioInclude | null
    /**
     * The data needed to create a Usuario.
    **/
    data: UsuarioCreateInput
  }


  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the Usuario
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsuarioInclude | null
    /**
     * The data needed to update a Usuario.
    **/
    data: UsuarioUpdateInput
    /**
     * Choose, which Usuario to update.
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs = {
    data: UsuarioUpdateManyMutationInput
    where?: UsuarioWhereInput
  }


  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the Usuario
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsuarioInclude | null
    /**
     * The filter to search for the Usuario to update in case it exists.
    **/
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
    **/
    create: UsuarioCreateInput
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
    **/
    update: UsuarioUpdateInput
  }


  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the Usuario
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsuarioInclude | null
    /**
     * Filter which Usuario to delete.
    **/
    where: UsuarioWhereUniqueInput
  }


  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs = {
    where?: UsuarioWhereInput
  }


  /**
   * Usuario without action
   */
  export type UsuarioArgs = {
    /**
     * Select specific fields to fetch from the Usuario
    **/
    select?: UsuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UsuarioInclude | null
  }



  /**
   * Model Estacion
   */


  export type AggregateEstacion = {
    count: number | null
    avg: EstacionAvgAggregateOutputType | null
    sum: EstacionSumAggregateOutputType | null
    min: EstacionMinAggregateOutputType | null
    max: EstacionMaxAggregateOutputType | null
  }

  export type EstacionAvgAggregateOutputType = {
    idEstacion: number
  }

  export type EstacionSumAggregateOutputType = {
    idEstacion: number
  }

  export type EstacionMinAggregateOutputType = {
    idEstacion: number
    nombre: string | null
  }

  export type EstacionMaxAggregateOutputType = {
    idEstacion: number
    nombre: string | null
  }

  export type EstacionCountAggregateOutputType = {
    idEstacion: number
    nombre: number | null
    _all: number
  }


  export type EstacionAvgAggregateInputType = {
    idEstacion?: true
  }

  export type EstacionSumAggregateInputType = {
    idEstacion?: true
  }

  export type EstacionMinAggregateInputType = {
    idEstacion?: true
    nombre?: true
  }

  export type EstacionMaxAggregateInputType = {
    idEstacion?: true
    nombre?: true
  }

  export type EstacionCountAggregateInputType = {
    idEstacion?: true
    nombre?: true
    _all?: true
  }

  export type AggregateEstacionArgs = {
    /**
     * Filter which Estacion to aggregate.
    **/
    where?: EstacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Estacions to fetch.
    **/
    orderBy?: Enumerable<EstacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: EstacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estacions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Estacions
    **/
    count?: true
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: EstacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: EstacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: EstacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: EstacionMaxAggregateInputType
  }

  export type GetEstacionAggregateType<T extends AggregateEstacionArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetEstacionAggregateScalarType<T[P]>
  }

  export type GetEstacionAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof EstacionAvgAggregateOutputType ? EstacionAvgAggregateOutputType[P] : never
  }

    



  export type EstacionSelect = {
    idEstacion?: boolean
    nombre?: boolean
    Bicicleta?: boolean | FindManyBicicletaArgs
  }

  export type EstacionInclude = {
    Bicicleta?: boolean | FindManyBicicletaArgs
  }

  export type EstacionGetPayload<
    S extends boolean | null | undefined | EstacionArgs,
    U = keyof S
      > = S extends true
        ? Estacion
    : S extends undefined
    ? never
    : S extends EstacionArgs | FindManyEstacionArgs
    ?'include' extends U
    ? Estacion  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Bicicleta'
        ? Array < BicicletaGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Estacion ?Estacion [P]
  : 
          P extends 'Bicicleta'
        ? Array < BicicletaGetPayload<S['select'][P]>>  : never
  } 
    : Estacion
  : Estacion


  export interface EstacionDelegate {
    /**
     * Find zero or one Estacion that matches the filter.
     * @param {FindUniqueEstacionArgs} args - Arguments to find a Estacion
     * @example
     * // Get one Estacion
     * const estacion = await prisma.estacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueEstacionArgs>(
      args: Subset<T, FindUniqueEstacionArgs>
    ): CheckSelect<T, Prisma__EstacionClient<Estacion | null>, Prisma__EstacionClient<EstacionGetPayload<T> | null>>

    /**
     * Find the first Estacion that matches the filter.
     * @param {FindFirstEstacionArgs} args - Arguments to find a Estacion
     * @example
     * // Get one Estacion
     * const estacion = await prisma.estacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstEstacionArgs>(
      args?: Subset<T, FindFirstEstacionArgs>
    ): CheckSelect<T, Prisma__EstacionClient<Estacion | null>, Prisma__EstacionClient<EstacionGetPayload<T> | null>>

    /**
     * Find zero or more Estacions that matches the filter.
     * @param {FindManyEstacionArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estacions
     * const estacions = await prisma.estacion.findMany()
     * 
     * // Get first 10 Estacions
     * const estacions = await prisma.estacion.findMany({ take: 10 })
     * 
     * // Only select the `idEstacion`
     * const estacionWithIdEstacionOnly = await prisma.estacion.findMany({ select: { idEstacion: true } })
     * 
    **/
    findMany<T extends FindManyEstacionArgs>(
      args?: Subset<T, FindManyEstacionArgs>
    ): CheckSelect<T, Promise<Array<Estacion>>, Promise<Array<EstacionGetPayload<T>>>>

    /**
     * Create a Estacion.
     * @param {EstacionCreateArgs} args - Arguments to create a Estacion.
     * @example
     * // Create one Estacion
     * const Estacion = await prisma.estacion.create({
     *   data: {
     *     // ... data to create a Estacion
     *   }
     * })
     * 
    **/
    create<T extends EstacionCreateArgs>(
      args: Subset<T, EstacionCreateArgs>
    ): CheckSelect<T, Prisma__EstacionClient<Estacion>, Prisma__EstacionClient<EstacionGetPayload<T>>>

    /**
     * Delete a Estacion.
     * @param {EstacionDeleteArgs} args - Arguments to delete one Estacion.
     * @example
     * // Delete one Estacion
     * const Estacion = await prisma.estacion.delete({
     *   where: {
     *     // ... filter to delete one Estacion
     *   }
     * })
     * 
    **/
    delete<T extends EstacionDeleteArgs>(
      args: Subset<T, EstacionDeleteArgs>
    ): CheckSelect<T, Prisma__EstacionClient<Estacion>, Prisma__EstacionClient<EstacionGetPayload<T>>>

    /**
     * Update one Estacion.
     * @param {EstacionUpdateArgs} args - Arguments to update one Estacion.
     * @example
     * // Update one Estacion
     * const estacion = await prisma.estacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EstacionUpdateArgs>(
      args: Subset<T, EstacionUpdateArgs>
    ): CheckSelect<T, Prisma__EstacionClient<Estacion>, Prisma__EstacionClient<EstacionGetPayload<T>>>

    /**
     * Delete zero or more Estacions.
     * @param {EstacionDeleteManyArgs} args - Arguments to filter Estacions to delete.
     * @example
     * // Delete a few Estacions
     * const { count } = await prisma.estacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EstacionDeleteManyArgs>(
      args?: Subset<T, EstacionDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Estacions.
     * @param {EstacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estacions
     * const estacion = await prisma.estacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EstacionUpdateManyArgs>(
      args: Subset<T, EstacionUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Estacion.
     * @param {EstacionUpsertArgs} args - Arguments to update or create a Estacion.
     * @example
     * // Update or create a Estacion
     * const estacion = await prisma.estacion.upsert({
     *   create: {
     *     // ... data to create a Estacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estacion we want to update
     *   }
     * })
    **/
    upsert<T extends EstacionUpsertArgs>(
      args: Subset<T, EstacionUpsertArgs>
    ): CheckSelect<T, Prisma__EstacionClient<Estacion>, Prisma__EstacionClient<EstacionGetPayload<T>>>

    /**
     * Find zero or one Estacion that matches the filter.
     * @param {FindUniqueEstacionArgs} args - Arguments to find a Estacion
     * @deprecated This will be deprecated please use prisma.estacion.findUnique
     * @example
     * // Get one Estacion
     * const estacion = await prisma.estacion.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueEstacionArgs>(
      args: Subset<T, FindUniqueEstacionArgs>
    ): CheckSelect<T, Prisma__EstacionClient<Estacion | null>, Prisma__EstacionClient<EstacionGetPayload<T> | null>>

    /**
     * Count the number of Estacions.
     * @param {FindManyEstacionArgs} args - Arguments to filter Estacions to count.
     * @example
     * // Count the number of Estacions
     * const count = await prisma.estacion.count({
     *   where: {
     *     // ... the filter for the Estacions we want to count
     *   }
     * })
    **/
    count(args?: Omit<FindManyEstacionArgs, 'select' | 'include'>): Promise<number>

    /**
     * Allows you to perform aggregations operations on a Estacion.
     * @param {AggregateEstacionArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregateEstacionArgs>(args: Subset<T, AggregateEstacionArgs>): Promise<GetEstacionAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Estacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EstacionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Bicicleta<T extends FindManyBicicletaArgs = {}>(args?: Subset<T, FindManyBicicletaArgs>): CheckSelect<T, Promise<Array<Bicicleta>>, Promise<Array<BicicletaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Estacion findUnique
   */
  export type FindUniqueEstacionArgs = {
    /**
     * Select specific fields to fetch from the Estacion
    **/
    select?: EstacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EstacionInclude | null
    /**
     * Filter, which Estacion to fetch.
    **/
    where: EstacionWhereUniqueInput
  }


  /**
   * Estacion findFirst
   */
  export type FindFirstEstacionArgs = {
    /**
     * Select specific fields to fetch from the Estacion
    **/
    select?: EstacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EstacionInclude | null
    /**
     * Filter, which Estacion to fetch.
    **/
    where?: EstacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Estacions to fetch.
    **/
    orderBy?: Enumerable<EstacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Estacions.
    **/
    cursor?: EstacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estacions.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Estacions.
    **/
    distinct?: Enumerable<EstacionScalarFieldEnum>
  }


  /**
   * Estacion findMany
   */
  export type FindManyEstacionArgs = {
    /**
     * Select specific fields to fetch from the Estacion
    **/
    select?: EstacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EstacionInclude | null
    /**
     * Filter, which Estacions to fetch.
    **/
    where?: EstacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Estacions to fetch.
    **/
    orderBy?: Enumerable<EstacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Estacions.
    **/
    cursor?: EstacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Estacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Estacions.
    **/
    skip?: number
    distinct?: Enumerable<EstacionScalarFieldEnum>
  }


  /**
   * Estacion create
   */
  export type EstacionCreateArgs = {
    /**
     * Select specific fields to fetch from the Estacion
    **/
    select?: EstacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EstacionInclude | null
    /**
     * The data needed to create a Estacion.
    **/
    data: EstacionCreateInput
  }


  /**
   * Estacion update
   */
  export type EstacionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Estacion
    **/
    select?: EstacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EstacionInclude | null
    /**
     * The data needed to update a Estacion.
    **/
    data: EstacionUpdateInput
    /**
     * Choose, which Estacion to update.
    **/
    where: EstacionWhereUniqueInput
  }


  /**
   * Estacion updateMany
   */
  export type EstacionUpdateManyArgs = {
    data: EstacionUpdateManyMutationInput
    where?: EstacionWhereInput
  }


  /**
   * Estacion upsert
   */
  export type EstacionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Estacion
    **/
    select?: EstacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EstacionInclude | null
    /**
     * The filter to search for the Estacion to update in case it exists.
    **/
    where: EstacionWhereUniqueInput
    /**
     * In case the Estacion found by the `where` argument doesn't exist, create a new Estacion with this data.
    **/
    create: EstacionCreateInput
    /**
     * In case the Estacion was found with the provided `where` argument, update it with this data.
    **/
    update: EstacionUpdateInput
  }


  /**
   * Estacion delete
   */
  export type EstacionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Estacion
    **/
    select?: EstacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EstacionInclude | null
    /**
     * Filter which Estacion to delete.
    **/
    where: EstacionWhereUniqueInput
  }


  /**
   * Estacion deleteMany
   */
  export type EstacionDeleteManyArgs = {
    where?: EstacionWhereInput
  }


  /**
   * Estacion without action
   */
  export type EstacionArgs = {
    /**
     * Select specific fields to fetch from the Estacion
    **/
    select?: EstacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: EstacionInclude | null
  }



  /**
   * Model Bicicleta
   */


  export type AggregateBicicleta = {
    count: number | null
    avg: BicicletaAvgAggregateOutputType | null
    sum: BicicletaSumAggregateOutputType | null
    min: BicicletaMinAggregateOutputType | null
    max: BicicletaMaxAggregateOutputType | null
  }

  export type BicicletaAvgAggregateOutputType = {
    idBicicleta: number
    estacion: number
  }

  export type BicicletaSumAggregateOutputType = {
    idBicicleta: number
    estacion: number
  }

  export type BicicletaMinAggregateOutputType = {
    idBicicleta: number
    estado: string | null
    estacion: number
  }

  export type BicicletaMaxAggregateOutputType = {
    idBicicleta: number
    estado: string | null
    estacion: number
  }

  export type BicicletaCountAggregateOutputType = {
    idBicicleta: number
    estado: number | null
    estacion: number
    _all: number
  }


  export type BicicletaAvgAggregateInputType = {
    idBicicleta?: true
    estacion?: true
  }

  export type BicicletaSumAggregateInputType = {
    idBicicleta?: true
    estacion?: true
  }

  export type BicicletaMinAggregateInputType = {
    idBicicleta?: true
    estado?: true
    estacion?: true
  }

  export type BicicletaMaxAggregateInputType = {
    idBicicleta?: true
    estado?: true
    estacion?: true
  }

  export type BicicletaCountAggregateInputType = {
    idBicicleta?: true
    estado?: true
    estacion?: true
    _all?: true
  }

  export type AggregateBicicletaArgs = {
    /**
     * Filter which Bicicleta to aggregate.
    **/
    where?: BicicletaWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Bicicletas to fetch.
    **/
    orderBy?: Enumerable<BicicletaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: BicicletaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bicicletas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bicicletas.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bicicletas
    **/
    count?: true
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: BicicletaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: BicicletaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: BicicletaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: BicicletaMaxAggregateInputType
  }

  export type GetBicicletaAggregateType<T extends AggregateBicicletaArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetBicicletaAggregateScalarType<T[P]>
  }

  export type GetBicicletaAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof BicicletaAvgAggregateOutputType ? BicicletaAvgAggregateOutputType[P] : never
  }

    



  export type BicicletaSelect = {
    idBicicleta?: boolean
    estado?: boolean
    Estacion?: boolean | EstacionArgs
    estacion?: boolean
    Alquiler?: boolean | FindManyAlquilerArgs
    Reportar?: boolean | FindManyReportarArgs
  }

  export type BicicletaInclude = {
    Estacion?: boolean | EstacionArgs
    Alquiler?: boolean | FindManyAlquilerArgs
    Reportar?: boolean | FindManyReportarArgs
  }

  export type BicicletaGetPayload<
    S extends boolean | null | undefined | BicicletaArgs,
    U = keyof S
      > = S extends true
        ? Bicicleta
    : S extends undefined
    ? never
    : S extends BicicletaArgs | FindManyBicicletaArgs
    ?'include' extends U
    ? Bicicleta  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Estacion'
        ? EstacionGetPayload<S['include'][P]> :
        P extends 'Alquiler'
        ? Array < AlquilerGetPayload<S['include'][P]>>  :
        P extends 'Reportar'
        ? Array < ReportarGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Bicicleta ?Bicicleta [P]
  : 
          P extends 'Estacion'
        ? EstacionGetPayload<S['select'][P]> :
        P extends 'Alquiler'
        ? Array < AlquilerGetPayload<S['select'][P]>>  :
        P extends 'Reportar'
        ? Array < ReportarGetPayload<S['select'][P]>>  : never
  } 
    : Bicicleta
  : Bicicleta


  export interface BicicletaDelegate {
    /**
     * Find zero or one Bicicleta that matches the filter.
     * @param {FindUniqueBicicletaArgs} args - Arguments to find a Bicicleta
     * @example
     * // Get one Bicicleta
     * const bicicleta = await prisma.bicicleta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueBicicletaArgs>(
      args: Subset<T, FindUniqueBicicletaArgs>
    ): CheckSelect<T, Prisma__BicicletaClient<Bicicleta | null>, Prisma__BicicletaClient<BicicletaGetPayload<T> | null>>

    /**
     * Find the first Bicicleta that matches the filter.
     * @param {FindFirstBicicletaArgs} args - Arguments to find a Bicicleta
     * @example
     * // Get one Bicicleta
     * const bicicleta = await prisma.bicicleta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstBicicletaArgs>(
      args?: Subset<T, FindFirstBicicletaArgs>
    ): CheckSelect<T, Prisma__BicicletaClient<Bicicleta | null>, Prisma__BicicletaClient<BicicletaGetPayload<T> | null>>

    /**
     * Find zero or more Bicicletas that matches the filter.
     * @param {FindManyBicicletaArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bicicletas
     * const bicicletas = await prisma.bicicleta.findMany()
     * 
     * // Get first 10 Bicicletas
     * const bicicletas = await prisma.bicicleta.findMany({ take: 10 })
     * 
     * // Only select the `idBicicleta`
     * const bicicletaWithIdBicicletaOnly = await prisma.bicicleta.findMany({ select: { idBicicleta: true } })
     * 
    **/
    findMany<T extends FindManyBicicletaArgs>(
      args?: Subset<T, FindManyBicicletaArgs>
    ): CheckSelect<T, Promise<Array<Bicicleta>>, Promise<Array<BicicletaGetPayload<T>>>>

    /**
     * Create a Bicicleta.
     * @param {BicicletaCreateArgs} args - Arguments to create a Bicicleta.
     * @example
     * // Create one Bicicleta
     * const Bicicleta = await prisma.bicicleta.create({
     *   data: {
     *     // ... data to create a Bicicleta
     *   }
     * })
     * 
    **/
    create<T extends BicicletaCreateArgs>(
      args: Subset<T, BicicletaCreateArgs>
    ): CheckSelect<T, Prisma__BicicletaClient<Bicicleta>, Prisma__BicicletaClient<BicicletaGetPayload<T>>>

    /**
     * Delete a Bicicleta.
     * @param {BicicletaDeleteArgs} args - Arguments to delete one Bicicleta.
     * @example
     * // Delete one Bicicleta
     * const Bicicleta = await prisma.bicicleta.delete({
     *   where: {
     *     // ... filter to delete one Bicicleta
     *   }
     * })
     * 
    **/
    delete<T extends BicicletaDeleteArgs>(
      args: Subset<T, BicicletaDeleteArgs>
    ): CheckSelect<T, Prisma__BicicletaClient<Bicicleta>, Prisma__BicicletaClient<BicicletaGetPayload<T>>>

    /**
     * Update one Bicicleta.
     * @param {BicicletaUpdateArgs} args - Arguments to update one Bicicleta.
     * @example
     * // Update one Bicicleta
     * const bicicleta = await prisma.bicicleta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BicicletaUpdateArgs>(
      args: Subset<T, BicicletaUpdateArgs>
    ): CheckSelect<T, Prisma__BicicletaClient<Bicicleta>, Prisma__BicicletaClient<BicicletaGetPayload<T>>>

    /**
     * Delete zero or more Bicicletas.
     * @param {BicicletaDeleteManyArgs} args - Arguments to filter Bicicletas to delete.
     * @example
     * // Delete a few Bicicletas
     * const { count } = await prisma.bicicleta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BicicletaDeleteManyArgs>(
      args?: Subset<T, BicicletaDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Bicicletas.
     * @param {BicicletaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bicicletas
     * const bicicleta = await prisma.bicicleta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BicicletaUpdateManyArgs>(
      args: Subset<T, BicicletaUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Bicicleta.
     * @param {BicicletaUpsertArgs} args - Arguments to update or create a Bicicleta.
     * @example
     * // Update or create a Bicicleta
     * const bicicleta = await prisma.bicicleta.upsert({
     *   create: {
     *     // ... data to create a Bicicleta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bicicleta we want to update
     *   }
     * })
    **/
    upsert<T extends BicicletaUpsertArgs>(
      args: Subset<T, BicicletaUpsertArgs>
    ): CheckSelect<T, Prisma__BicicletaClient<Bicicleta>, Prisma__BicicletaClient<BicicletaGetPayload<T>>>

    /**
     * Find zero or one Bicicleta that matches the filter.
     * @param {FindUniqueBicicletaArgs} args - Arguments to find a Bicicleta
     * @deprecated This will be deprecated please use prisma.bicicleta.findUnique
     * @example
     * // Get one Bicicleta
     * const bicicleta = await prisma.bicicleta.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueBicicletaArgs>(
      args: Subset<T, FindUniqueBicicletaArgs>
    ): CheckSelect<T, Prisma__BicicletaClient<Bicicleta | null>, Prisma__BicicletaClient<BicicletaGetPayload<T> | null>>

    /**
     * Count the number of Bicicletas.
     * @param {FindManyBicicletaArgs} args - Arguments to filter Bicicletas to count.
     * @example
     * // Count the number of Bicicletas
     * const count = await prisma.bicicleta.count({
     *   where: {
     *     // ... the filter for the Bicicletas we want to count
     *   }
     * })
    **/
    count(args?: Omit<FindManyBicicletaArgs, 'select' | 'include'>): Promise<number>

    /**
     * Allows you to perform aggregations operations on a Bicicleta.
     * @param {AggregateBicicletaArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregateBicicletaArgs>(args: Subset<T, AggregateBicicletaArgs>): Promise<GetBicicletaAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Bicicleta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BicicletaClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Estacion<T extends EstacionArgs = {}>(args?: Subset<T, EstacionArgs>): CheckSelect<T, Prisma__EstacionClient<Estacion | null>, Prisma__EstacionClient<EstacionGetPayload<T> | null>>;

    Alquiler<T extends FindManyAlquilerArgs = {}>(args?: Subset<T, FindManyAlquilerArgs>): CheckSelect<T, Promise<Array<Alquiler>>, Promise<Array<AlquilerGetPayload<T>>>>;

    Reportar<T extends FindManyReportarArgs = {}>(args?: Subset<T, FindManyReportarArgs>): CheckSelect<T, Promise<Array<Reportar>>, Promise<Array<ReportarGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Bicicleta findUnique
   */
  export type FindUniqueBicicletaArgs = {
    /**
     * Select specific fields to fetch from the Bicicleta
    **/
    select?: BicicletaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BicicletaInclude | null
    /**
     * Filter, which Bicicleta to fetch.
    **/
    where: BicicletaWhereUniqueInput
  }


  /**
   * Bicicleta findFirst
   */
  export type FindFirstBicicletaArgs = {
    /**
     * Select specific fields to fetch from the Bicicleta
    **/
    select?: BicicletaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BicicletaInclude | null
    /**
     * Filter, which Bicicleta to fetch.
    **/
    where?: BicicletaWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Bicicletas to fetch.
    **/
    orderBy?: Enumerable<BicicletaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bicicletas.
    **/
    cursor?: BicicletaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bicicletas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bicicletas.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Bicicletas.
    **/
    distinct?: Enumerable<BicicletaScalarFieldEnum>
  }


  /**
   * Bicicleta findMany
   */
  export type FindManyBicicletaArgs = {
    /**
     * Select specific fields to fetch from the Bicicleta
    **/
    select?: BicicletaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BicicletaInclude | null
    /**
     * Filter, which Bicicletas to fetch.
    **/
    where?: BicicletaWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Bicicletas to fetch.
    **/
    orderBy?: Enumerable<BicicletaOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bicicletas.
    **/
    cursor?: BicicletaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bicicletas from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bicicletas.
    **/
    skip?: number
    distinct?: Enumerable<BicicletaScalarFieldEnum>
  }


  /**
   * Bicicleta create
   */
  export type BicicletaCreateArgs = {
    /**
     * Select specific fields to fetch from the Bicicleta
    **/
    select?: BicicletaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BicicletaInclude | null
    /**
     * The data needed to create a Bicicleta.
    **/
    data: BicicletaCreateInput
  }


  /**
   * Bicicleta update
   */
  export type BicicletaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Bicicleta
    **/
    select?: BicicletaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BicicletaInclude | null
    /**
     * The data needed to update a Bicicleta.
    **/
    data: BicicletaUpdateInput
    /**
     * Choose, which Bicicleta to update.
    **/
    where: BicicletaWhereUniqueInput
  }


  /**
   * Bicicleta updateMany
   */
  export type BicicletaUpdateManyArgs = {
    data: BicicletaUpdateManyMutationInput
    where?: BicicletaWhereInput
  }


  /**
   * Bicicleta upsert
   */
  export type BicicletaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Bicicleta
    **/
    select?: BicicletaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BicicletaInclude | null
    /**
     * The filter to search for the Bicicleta to update in case it exists.
    **/
    where: BicicletaWhereUniqueInput
    /**
     * In case the Bicicleta found by the `where` argument doesn't exist, create a new Bicicleta with this data.
    **/
    create: BicicletaCreateInput
    /**
     * In case the Bicicleta was found with the provided `where` argument, update it with this data.
    **/
    update: BicicletaUpdateInput
  }


  /**
   * Bicicleta delete
   */
  export type BicicletaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Bicicleta
    **/
    select?: BicicletaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BicicletaInclude | null
    /**
     * Filter which Bicicleta to delete.
    **/
    where: BicicletaWhereUniqueInput
  }


  /**
   * Bicicleta deleteMany
   */
  export type BicicletaDeleteManyArgs = {
    where?: BicicletaWhereInput
  }


  /**
   * Bicicleta without action
   */
  export type BicicletaArgs = {
    /**
     * Select specific fields to fetch from the Bicicleta
    **/
    select?: BicicletaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BicicletaInclude | null
  }



  /**
   * Model Alquiler
   */


  export type AggregateAlquiler = {
    count: number | null
    avg: AlquilerAvgAggregateOutputType | null
    sum: AlquilerSumAggregateOutputType | null
    min: AlquilerMinAggregateOutputType | null
    max: AlquilerMaxAggregateOutputType | null
  }

  export type AlquilerAvgAggregateOutputType = {
    idAlquiler: number
    usuario: number
    bicicleta: number
  }

  export type AlquilerSumAggregateOutputType = {
    idAlquiler: number
    usuario: number
    bicicleta: number
  }

  export type AlquilerMinAggregateOutputType = {
    idAlquiler: number
    usuario: number
    bicicleta: number
    fecha: Date | null
    estado: boolean | null
  }

  export type AlquilerMaxAggregateOutputType = {
    idAlquiler: number
    usuario: number
    bicicleta: number
    fecha: Date | null
    estado: boolean | null
  }

  export type AlquilerCountAggregateOutputType = {
    idAlquiler: number
    usuario: number
    bicicleta: number
    fecha: number | null
    estado: number | null
    _all: number
  }


  export type AlquilerAvgAggregateInputType = {
    idAlquiler?: true
    usuario?: true
    bicicleta?: true
  }

  export type AlquilerSumAggregateInputType = {
    idAlquiler?: true
    usuario?: true
    bicicleta?: true
  }

  export type AlquilerMinAggregateInputType = {
    idAlquiler?: true
    usuario?: true
    bicicleta?: true
    fecha?: true
    estado?: true
  }

  export type AlquilerMaxAggregateInputType = {
    idAlquiler?: true
    usuario?: true
    bicicleta?: true
    fecha?: true
    estado?: true
  }

  export type AlquilerCountAggregateInputType = {
    idAlquiler?: true
    usuario?: true
    bicicleta?: true
    fecha?: true
    estado?: true
    _all?: true
  }

  export type AggregateAlquilerArgs = {
    /**
     * Filter which Alquiler to aggregate.
    **/
    where?: AlquilerWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Alquilers to fetch.
    **/
    orderBy?: Enumerable<AlquilerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AlquilerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alquilers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alquilers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alquilers
    **/
    count?: true
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: AlquilerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: AlquilerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AlquilerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AlquilerMaxAggregateInputType
  }

  export type GetAlquilerAggregateType<T extends AggregateAlquilerArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetAlquilerAggregateScalarType<T[P]>
  }

  export type GetAlquilerAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof AlquilerAvgAggregateOutputType ? AlquilerAvgAggregateOutputType[P] : never
  }

    



  export type AlquilerSelect = {
    idAlquiler?: boolean
    usuario?: boolean
    bicicleta?: boolean
    fecha?: boolean
    Bicicleta?: boolean | BicicletaArgs
    Usuario?: boolean | UsuarioArgs
    estado?: boolean
  }

  export type AlquilerInclude = {
    Bicicleta?: boolean | BicicletaArgs
    Usuario?: boolean | UsuarioArgs
  }

  export type AlquilerGetPayload<
    S extends boolean | null | undefined | AlquilerArgs,
    U = keyof S
      > = S extends true
        ? Alquiler
    : S extends undefined
    ? never
    : S extends AlquilerArgs | FindManyAlquilerArgs
    ?'include' extends U
    ? Alquiler  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Bicicleta'
        ? BicicletaGetPayload<S['include'][P]> :
        P extends 'Usuario'
        ? UsuarioGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Alquiler ?Alquiler [P]
  : 
          P extends 'Bicicleta'
        ? BicicletaGetPayload<S['select'][P]> :
        P extends 'Usuario'
        ? UsuarioGetPayload<S['select'][P]> : never
  } 
    : Alquiler
  : Alquiler


  export interface AlquilerDelegate {
    /**
     * Find zero or one Alquiler that matches the filter.
     * @param {FindUniqueAlquilerArgs} args - Arguments to find a Alquiler
     * @example
     * // Get one Alquiler
     * const alquiler = await prisma.alquiler.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueAlquilerArgs>(
      args: Subset<T, FindUniqueAlquilerArgs>
    ): CheckSelect<T, Prisma__AlquilerClient<Alquiler | null>, Prisma__AlquilerClient<AlquilerGetPayload<T> | null>>

    /**
     * Find the first Alquiler that matches the filter.
     * @param {FindFirstAlquilerArgs} args - Arguments to find a Alquiler
     * @example
     * // Get one Alquiler
     * const alquiler = await prisma.alquiler.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstAlquilerArgs>(
      args?: Subset<T, FindFirstAlquilerArgs>
    ): CheckSelect<T, Prisma__AlquilerClient<Alquiler | null>, Prisma__AlquilerClient<AlquilerGetPayload<T> | null>>

    /**
     * Find zero or more Alquilers that matches the filter.
     * @param {FindManyAlquilerArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alquilers
     * const alquilers = await prisma.alquiler.findMany()
     * 
     * // Get first 10 Alquilers
     * const alquilers = await prisma.alquiler.findMany({ take: 10 })
     * 
     * // Only select the `idAlquiler`
     * const alquilerWithIdAlquilerOnly = await prisma.alquiler.findMany({ select: { idAlquiler: true } })
     * 
    **/
    findMany<T extends FindManyAlquilerArgs>(
      args?: Subset<T, FindManyAlquilerArgs>
    ): CheckSelect<T, Promise<Array<Alquiler>>, Promise<Array<AlquilerGetPayload<T>>>>

    /**
     * Create a Alquiler.
     * @param {AlquilerCreateArgs} args - Arguments to create a Alquiler.
     * @example
     * // Create one Alquiler
     * const Alquiler = await prisma.alquiler.create({
     *   data: {
     *     // ... data to create a Alquiler
     *   }
     * })
     * 
    **/
    create<T extends AlquilerCreateArgs>(
      args: Subset<T, AlquilerCreateArgs>
    ): CheckSelect<T, Prisma__AlquilerClient<Alquiler>, Prisma__AlquilerClient<AlquilerGetPayload<T>>>

    /**
     * Delete a Alquiler.
     * @param {AlquilerDeleteArgs} args - Arguments to delete one Alquiler.
     * @example
     * // Delete one Alquiler
     * const Alquiler = await prisma.alquiler.delete({
     *   where: {
     *     // ... filter to delete one Alquiler
     *   }
     * })
     * 
    **/
    delete<T extends AlquilerDeleteArgs>(
      args: Subset<T, AlquilerDeleteArgs>
    ): CheckSelect<T, Prisma__AlquilerClient<Alquiler>, Prisma__AlquilerClient<AlquilerGetPayload<T>>>

    /**
     * Update one Alquiler.
     * @param {AlquilerUpdateArgs} args - Arguments to update one Alquiler.
     * @example
     * // Update one Alquiler
     * const alquiler = await prisma.alquiler.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlquilerUpdateArgs>(
      args: Subset<T, AlquilerUpdateArgs>
    ): CheckSelect<T, Prisma__AlquilerClient<Alquiler>, Prisma__AlquilerClient<AlquilerGetPayload<T>>>

    /**
     * Delete zero or more Alquilers.
     * @param {AlquilerDeleteManyArgs} args - Arguments to filter Alquilers to delete.
     * @example
     * // Delete a few Alquilers
     * const { count } = await prisma.alquiler.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlquilerDeleteManyArgs>(
      args?: Subset<T, AlquilerDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Alquilers.
     * @param {AlquilerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alquilers
     * const alquiler = await prisma.alquiler.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlquilerUpdateManyArgs>(
      args: Subset<T, AlquilerUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Alquiler.
     * @param {AlquilerUpsertArgs} args - Arguments to update or create a Alquiler.
     * @example
     * // Update or create a Alquiler
     * const alquiler = await prisma.alquiler.upsert({
     *   create: {
     *     // ... data to create a Alquiler
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alquiler we want to update
     *   }
     * })
    **/
    upsert<T extends AlquilerUpsertArgs>(
      args: Subset<T, AlquilerUpsertArgs>
    ): CheckSelect<T, Prisma__AlquilerClient<Alquiler>, Prisma__AlquilerClient<AlquilerGetPayload<T>>>

    /**
     * Find zero or one Alquiler that matches the filter.
     * @param {FindUniqueAlquilerArgs} args - Arguments to find a Alquiler
     * @deprecated This will be deprecated please use prisma.alquiler.findUnique
     * @example
     * // Get one Alquiler
     * const alquiler = await prisma.alquiler.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueAlquilerArgs>(
      args: Subset<T, FindUniqueAlquilerArgs>
    ): CheckSelect<T, Prisma__AlquilerClient<Alquiler | null>, Prisma__AlquilerClient<AlquilerGetPayload<T> | null>>

    /**
     * Count the number of Alquilers.
     * @param {FindManyAlquilerArgs} args - Arguments to filter Alquilers to count.
     * @example
     * // Count the number of Alquilers
     * const count = await prisma.alquiler.count({
     *   where: {
     *     // ... the filter for the Alquilers we want to count
     *   }
     * })
    **/
    count(args?: Omit<FindManyAlquilerArgs, 'select' | 'include'>): Promise<number>

    /**
     * Allows you to perform aggregations operations on a Alquiler.
     * @param {AggregateAlquilerArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregateAlquilerArgs>(args: Subset<T, AggregateAlquilerArgs>): Promise<GetAlquilerAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Alquiler.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlquilerClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Bicicleta<T extends BicicletaArgs = {}>(args?: Subset<T, BicicletaArgs>): CheckSelect<T, Prisma__BicicletaClient<Bicicleta | null>, Prisma__BicicletaClient<BicicletaGetPayload<T> | null>>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Alquiler findUnique
   */
  export type FindUniqueAlquilerArgs = {
    /**
     * Select specific fields to fetch from the Alquiler
    **/
    select?: AlquilerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AlquilerInclude | null
    /**
     * Filter, which Alquiler to fetch.
    **/
    where: AlquilerWhereUniqueInput
  }


  /**
   * Alquiler findFirst
   */
  export type FindFirstAlquilerArgs = {
    /**
     * Select specific fields to fetch from the Alquiler
    **/
    select?: AlquilerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AlquilerInclude | null
    /**
     * Filter, which Alquiler to fetch.
    **/
    where?: AlquilerWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Alquilers to fetch.
    **/
    orderBy?: Enumerable<AlquilerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alquilers.
    **/
    cursor?: AlquilerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alquilers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alquilers.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Alquilers.
    **/
    distinct?: Enumerable<AlquilerScalarFieldEnum>
  }


  /**
   * Alquiler findMany
   */
  export type FindManyAlquilerArgs = {
    /**
     * Select specific fields to fetch from the Alquiler
    **/
    select?: AlquilerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AlquilerInclude | null
    /**
     * Filter, which Alquilers to fetch.
    **/
    where?: AlquilerWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Alquilers to fetch.
    **/
    orderBy?: Enumerable<AlquilerOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alquilers.
    **/
    cursor?: AlquilerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alquilers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alquilers.
    **/
    skip?: number
    distinct?: Enumerable<AlquilerScalarFieldEnum>
  }


  /**
   * Alquiler create
   */
  export type AlquilerCreateArgs = {
    /**
     * Select specific fields to fetch from the Alquiler
    **/
    select?: AlquilerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AlquilerInclude | null
    /**
     * The data needed to create a Alquiler.
    **/
    data: AlquilerCreateInput
  }


  /**
   * Alquiler update
   */
  export type AlquilerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Alquiler
    **/
    select?: AlquilerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AlquilerInclude | null
    /**
     * The data needed to update a Alquiler.
    **/
    data: AlquilerUpdateInput
    /**
     * Choose, which Alquiler to update.
    **/
    where: AlquilerWhereUniqueInput
  }


  /**
   * Alquiler updateMany
   */
  export type AlquilerUpdateManyArgs = {
    data: AlquilerUpdateManyMutationInput
    where?: AlquilerWhereInput
  }


  /**
   * Alquiler upsert
   */
  export type AlquilerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Alquiler
    **/
    select?: AlquilerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AlquilerInclude | null
    /**
     * The filter to search for the Alquiler to update in case it exists.
    **/
    where: AlquilerWhereUniqueInput
    /**
     * In case the Alquiler found by the `where` argument doesn't exist, create a new Alquiler with this data.
    **/
    create: AlquilerCreateInput
    /**
     * In case the Alquiler was found with the provided `where` argument, update it with this data.
    **/
    update: AlquilerUpdateInput
  }


  /**
   * Alquiler delete
   */
  export type AlquilerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Alquiler
    **/
    select?: AlquilerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AlquilerInclude | null
    /**
     * Filter which Alquiler to delete.
    **/
    where: AlquilerWhereUniqueInput
  }


  /**
   * Alquiler deleteMany
   */
  export type AlquilerDeleteManyArgs = {
    where?: AlquilerWhereInput
  }


  /**
   * Alquiler without action
   */
  export type AlquilerArgs = {
    /**
     * Select specific fields to fetch from the Alquiler
    **/
    select?: AlquilerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AlquilerInclude | null
  }



  /**
   * Model Reportar
   */


  export type AggregateReportar = {
    count: number | null
    avg: ReportarAvgAggregateOutputType | null
    sum: ReportarSumAggregateOutputType | null
    min: ReportarMinAggregateOutputType | null
    max: ReportarMaxAggregateOutputType | null
  }

  export type ReportarAvgAggregateOutputType = {
    idReportar: number
    usuario: number
    bicicleta: number
  }

  export type ReportarSumAggregateOutputType = {
    idReportar: number
    usuario: number
    bicicleta: number
  }

  export type ReportarMinAggregateOutputType = {
    idReportar: number
    usuario: number
    bicicleta: number
    contenido: string | null
    fecha: Date | null
    estado: boolean | null
  }

  export type ReportarMaxAggregateOutputType = {
    idReportar: number
    usuario: number
    bicicleta: number
    contenido: string | null
    fecha: Date | null
    estado: boolean | null
  }

  export type ReportarCountAggregateOutputType = {
    idReportar: number
    usuario: number
    bicicleta: number
    contenido: number | null
    fecha: number | null
    estado: number | null
    _all: number
  }


  export type ReportarAvgAggregateInputType = {
    idReportar?: true
    usuario?: true
    bicicleta?: true
  }

  export type ReportarSumAggregateInputType = {
    idReportar?: true
    usuario?: true
    bicicleta?: true
  }

  export type ReportarMinAggregateInputType = {
    idReportar?: true
    usuario?: true
    bicicleta?: true
    contenido?: true
    fecha?: true
    estado?: true
  }

  export type ReportarMaxAggregateInputType = {
    idReportar?: true
    usuario?: true
    bicicleta?: true
    contenido?: true
    fecha?: true
    estado?: true
  }

  export type ReportarCountAggregateInputType = {
    idReportar?: true
    usuario?: true
    bicicleta?: true
    contenido?: true
    fecha?: true
    estado?: true
    _all?: true
  }

  export type AggregateReportarArgs = {
    /**
     * Filter which Reportar to aggregate.
    **/
    where?: ReportarWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Reportars to fetch.
    **/
    orderBy?: Enumerable<ReportarOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReportarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportars from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportars.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reportars
    **/
    count?: true
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReportarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReportarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReportarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReportarMaxAggregateInputType
  }

  export type GetReportarAggregateType<T extends AggregateReportarArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetReportarAggregateScalarType<T[P]>
  }

  export type GetReportarAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof ReportarAvgAggregateOutputType ? ReportarAvgAggregateOutputType[P] : never
  }

    



  export type ReportarSelect = {
    idReportar?: boolean
    usuario?: boolean
    bicicleta?: boolean
    contenido?: boolean
    fecha?: boolean
    Bicicleta?: boolean | BicicletaArgs
    Usuario?: boolean | UsuarioArgs
    estado?: boolean
  }

  export type ReportarInclude = {
    Bicicleta?: boolean | BicicletaArgs
    Usuario?: boolean | UsuarioArgs
  }

  export type ReportarGetPayload<
    S extends boolean | null | undefined | ReportarArgs,
    U = keyof S
      > = S extends true
        ? Reportar
    : S extends undefined
    ? never
    : S extends ReportarArgs | FindManyReportarArgs
    ?'include' extends U
    ? Reportar  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Bicicleta'
        ? BicicletaGetPayload<S['include'][P]> :
        P extends 'Usuario'
        ? UsuarioGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Reportar ?Reportar [P]
  : 
          P extends 'Bicicleta'
        ? BicicletaGetPayload<S['select'][P]> :
        P extends 'Usuario'
        ? UsuarioGetPayload<S['select'][P]> : never
  } 
    : Reportar
  : Reportar


  export interface ReportarDelegate {
    /**
     * Find zero or one Reportar that matches the filter.
     * @param {FindUniqueReportarArgs} args - Arguments to find a Reportar
     * @example
     * // Get one Reportar
     * const reportar = await prisma.reportar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueReportarArgs>(
      args: Subset<T, FindUniqueReportarArgs>
    ): CheckSelect<T, Prisma__ReportarClient<Reportar | null>, Prisma__ReportarClient<ReportarGetPayload<T> | null>>

    /**
     * Find the first Reportar that matches the filter.
     * @param {FindFirstReportarArgs} args - Arguments to find a Reportar
     * @example
     * // Get one Reportar
     * const reportar = await prisma.reportar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstReportarArgs>(
      args?: Subset<T, FindFirstReportarArgs>
    ): CheckSelect<T, Prisma__ReportarClient<Reportar | null>, Prisma__ReportarClient<ReportarGetPayload<T> | null>>

    /**
     * Find zero or more Reportars that matches the filter.
     * @param {FindManyReportarArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reportars
     * const reportars = await prisma.reportar.findMany()
     * 
     * // Get first 10 Reportars
     * const reportars = await prisma.reportar.findMany({ take: 10 })
     * 
     * // Only select the `idReportar`
     * const reportarWithIdReportarOnly = await prisma.reportar.findMany({ select: { idReportar: true } })
     * 
    **/
    findMany<T extends FindManyReportarArgs>(
      args?: Subset<T, FindManyReportarArgs>
    ): CheckSelect<T, Promise<Array<Reportar>>, Promise<Array<ReportarGetPayload<T>>>>

    /**
     * Create a Reportar.
     * @param {ReportarCreateArgs} args - Arguments to create a Reportar.
     * @example
     * // Create one Reportar
     * const Reportar = await prisma.reportar.create({
     *   data: {
     *     // ... data to create a Reportar
     *   }
     * })
     * 
    **/
    create<T extends ReportarCreateArgs>(
      args: Subset<T, ReportarCreateArgs>
    ): CheckSelect<T, Prisma__ReportarClient<Reportar>, Prisma__ReportarClient<ReportarGetPayload<T>>>

    /**
     * Delete a Reportar.
     * @param {ReportarDeleteArgs} args - Arguments to delete one Reportar.
     * @example
     * // Delete one Reportar
     * const Reportar = await prisma.reportar.delete({
     *   where: {
     *     // ... filter to delete one Reportar
     *   }
     * })
     * 
    **/
    delete<T extends ReportarDeleteArgs>(
      args: Subset<T, ReportarDeleteArgs>
    ): CheckSelect<T, Prisma__ReportarClient<Reportar>, Prisma__ReportarClient<ReportarGetPayload<T>>>

    /**
     * Update one Reportar.
     * @param {ReportarUpdateArgs} args - Arguments to update one Reportar.
     * @example
     * // Update one Reportar
     * const reportar = await prisma.reportar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportarUpdateArgs>(
      args: Subset<T, ReportarUpdateArgs>
    ): CheckSelect<T, Prisma__ReportarClient<Reportar>, Prisma__ReportarClient<ReportarGetPayload<T>>>

    /**
     * Delete zero or more Reportars.
     * @param {ReportarDeleteManyArgs} args - Arguments to filter Reportars to delete.
     * @example
     * // Delete a few Reportars
     * const { count } = await prisma.reportar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportarDeleteManyArgs>(
      args?: Subset<T, ReportarDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Reportars.
     * @param {ReportarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reportars
     * const reportar = await prisma.reportar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportarUpdateManyArgs>(
      args: Subset<T, ReportarUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Reportar.
     * @param {ReportarUpsertArgs} args - Arguments to update or create a Reportar.
     * @example
     * // Update or create a Reportar
     * const reportar = await prisma.reportar.upsert({
     *   create: {
     *     // ... data to create a Reportar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reportar we want to update
     *   }
     * })
    **/
    upsert<T extends ReportarUpsertArgs>(
      args: Subset<T, ReportarUpsertArgs>
    ): CheckSelect<T, Prisma__ReportarClient<Reportar>, Prisma__ReportarClient<ReportarGetPayload<T>>>

    /**
     * Find zero or one Reportar that matches the filter.
     * @param {FindUniqueReportarArgs} args - Arguments to find a Reportar
     * @deprecated This will be deprecated please use prisma.reportar.findUnique
     * @example
     * // Get one Reportar
     * const reportar = await prisma.reportar.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueReportarArgs>(
      args: Subset<T, FindUniqueReportarArgs>
    ): CheckSelect<T, Prisma__ReportarClient<Reportar | null>, Prisma__ReportarClient<ReportarGetPayload<T> | null>>

    /**
     * Count the number of Reportars.
     * @param {FindManyReportarArgs} args - Arguments to filter Reportars to count.
     * @example
     * // Count the number of Reportars
     * const count = await prisma.reportar.count({
     *   where: {
     *     // ... the filter for the Reportars we want to count
     *   }
     * })
    **/
    count(args?: Omit<FindManyReportarArgs, 'select' | 'include'>): Promise<number>

    /**
     * Allows you to perform aggregations operations on a Reportar.
     * @param {AggregateReportarArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregateReportarArgs>(args: Subset<T, AggregateReportarArgs>): Promise<GetReportarAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Reportar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportarClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Bicicleta<T extends BicicletaArgs = {}>(args?: Subset<T, BicicletaArgs>): CheckSelect<T, Prisma__BicicletaClient<Bicicleta | null>, Prisma__BicicletaClient<BicicletaGetPayload<T> | null>>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Reportar findUnique
   */
  export type FindUniqueReportarArgs = {
    /**
     * Select specific fields to fetch from the Reportar
    **/
    select?: ReportarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportarInclude | null
    /**
     * Filter, which Reportar to fetch.
    **/
    where: ReportarWhereUniqueInput
  }


  /**
   * Reportar findFirst
   */
  export type FindFirstReportarArgs = {
    /**
     * Select specific fields to fetch from the Reportar
    **/
    select?: ReportarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportarInclude | null
    /**
     * Filter, which Reportar to fetch.
    **/
    where?: ReportarWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Reportars to fetch.
    **/
    orderBy?: Enumerable<ReportarOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reportars.
    **/
    cursor?: ReportarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportars from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportars.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Reportars.
    **/
    distinct?: Enumerable<ReportarScalarFieldEnum>
  }


  /**
   * Reportar findMany
   */
  export type FindManyReportarArgs = {
    /**
     * Select specific fields to fetch from the Reportar
    **/
    select?: ReportarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportarInclude | null
    /**
     * Filter, which Reportars to fetch.
    **/
    where?: ReportarWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Reportars to fetch.
    **/
    orderBy?: Enumerable<ReportarOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reportars.
    **/
    cursor?: ReportarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportars from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportars.
    **/
    skip?: number
    distinct?: Enumerable<ReportarScalarFieldEnum>
  }


  /**
   * Reportar create
   */
  export type ReportarCreateArgs = {
    /**
     * Select specific fields to fetch from the Reportar
    **/
    select?: ReportarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportarInclude | null
    /**
     * The data needed to create a Reportar.
    **/
    data: ReportarCreateInput
  }


  /**
   * Reportar update
   */
  export type ReportarUpdateArgs = {
    /**
     * Select specific fields to fetch from the Reportar
    **/
    select?: ReportarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportarInclude | null
    /**
     * The data needed to update a Reportar.
    **/
    data: ReportarUpdateInput
    /**
     * Choose, which Reportar to update.
    **/
    where: ReportarWhereUniqueInput
  }


  /**
   * Reportar updateMany
   */
  export type ReportarUpdateManyArgs = {
    data: ReportarUpdateManyMutationInput
    where?: ReportarWhereInput
  }


  /**
   * Reportar upsert
   */
  export type ReportarUpsertArgs = {
    /**
     * Select specific fields to fetch from the Reportar
    **/
    select?: ReportarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportarInclude | null
    /**
     * The filter to search for the Reportar to update in case it exists.
    **/
    where: ReportarWhereUniqueInput
    /**
     * In case the Reportar found by the `where` argument doesn't exist, create a new Reportar with this data.
    **/
    create: ReportarCreateInput
    /**
     * In case the Reportar was found with the provided `where` argument, update it with this data.
    **/
    update: ReportarUpdateInput
  }


  /**
   * Reportar delete
   */
  export type ReportarDeleteArgs = {
    /**
     * Select specific fields to fetch from the Reportar
    **/
    select?: ReportarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportarInclude | null
    /**
     * Filter which Reportar to delete.
    **/
    where: ReportarWhereUniqueInput
  }


  /**
   * Reportar deleteMany
   */
  export type ReportarDeleteManyArgs = {
    where?: ReportarWhereInput
  }


  /**
   * Reportar without action
   */
  export type ReportarArgs = {
    /**
     * Select specific fields to fetch from the Reportar
    **/
    select?: ReportarSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReportarInclude | null
  }



  /**
   * Model Foro
   */


  export type AggregateForo = {
    count: number | null
    avg: ForoAvgAggregateOutputType | null
    sum: ForoSumAggregateOutputType | null
    min: ForoMinAggregateOutputType | null
    max: ForoMaxAggregateOutputType | null
  }

  export type ForoAvgAggregateOutputType = {
    idForo: number
  }

  export type ForoSumAggregateOutputType = {
    idForo: number
  }

  export type ForoMinAggregateOutputType = {
    idForo: number
    descripcion: string | null
  }

  export type ForoMaxAggregateOutputType = {
    idForo: number
    descripcion: string | null
  }

  export type ForoCountAggregateOutputType = {
    idForo: number
    descripcion: number | null
    _all: number
  }


  export type ForoAvgAggregateInputType = {
    idForo?: true
  }

  export type ForoSumAggregateInputType = {
    idForo?: true
  }

  export type ForoMinAggregateInputType = {
    idForo?: true
    descripcion?: true
  }

  export type ForoMaxAggregateInputType = {
    idForo?: true
    descripcion?: true
  }

  export type ForoCountAggregateInputType = {
    idForo?: true
    descripcion?: true
    _all?: true
  }

  export type AggregateForoArgs = {
    /**
     * Filter which Foro to aggregate.
    **/
    where?: ForoWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Foros to fetch.
    **/
    orderBy?: Enumerable<ForoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ForoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foros from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foros.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foros
    **/
    count?: true
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ForoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ForoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ForoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ForoMaxAggregateInputType
  }

  export type GetForoAggregateType<T extends AggregateForoArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetForoAggregateScalarType<T[P]>
  }

  export type GetForoAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof ForoAvgAggregateOutputType ? ForoAvgAggregateOutputType[P] : never
  }

    



  export type ForoSelect = {
    idForo?: boolean
    descripcion?: boolean
    Informacion?: boolean | FindManyInformacionArgs
    Publicacion?: boolean | FindManyPublicacionArgs
  }

  export type ForoInclude = {
    Informacion?: boolean | FindManyInformacionArgs
    Publicacion?: boolean | FindManyPublicacionArgs
  }

  export type ForoGetPayload<
    S extends boolean | null | undefined | ForoArgs,
    U = keyof S
      > = S extends true
        ? Foro
    : S extends undefined
    ? never
    : S extends ForoArgs | FindManyForoArgs
    ?'include' extends U
    ? Foro  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Informacion'
        ? Array < InformacionGetPayload<S['include'][P]>>  :
        P extends 'Publicacion'
        ? Array < PublicacionGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Foro ?Foro [P]
  : 
          P extends 'Informacion'
        ? Array < InformacionGetPayload<S['select'][P]>>  :
        P extends 'Publicacion'
        ? Array < PublicacionGetPayload<S['select'][P]>>  : never
  } 
    : Foro
  : Foro


  export interface ForoDelegate {
    /**
     * Find zero or one Foro that matches the filter.
     * @param {FindUniqueForoArgs} args - Arguments to find a Foro
     * @example
     * // Get one Foro
     * const foro = await prisma.foro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueForoArgs>(
      args: Subset<T, FindUniqueForoArgs>
    ): CheckSelect<T, Prisma__ForoClient<Foro | null>, Prisma__ForoClient<ForoGetPayload<T> | null>>

    /**
     * Find the first Foro that matches the filter.
     * @param {FindFirstForoArgs} args - Arguments to find a Foro
     * @example
     * // Get one Foro
     * const foro = await prisma.foro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstForoArgs>(
      args?: Subset<T, FindFirstForoArgs>
    ): CheckSelect<T, Prisma__ForoClient<Foro | null>, Prisma__ForoClient<ForoGetPayload<T> | null>>

    /**
     * Find zero or more Foros that matches the filter.
     * @param {FindManyForoArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foros
     * const foros = await prisma.foro.findMany()
     * 
     * // Get first 10 Foros
     * const foros = await prisma.foro.findMany({ take: 10 })
     * 
     * // Only select the `idForo`
     * const foroWithIdForoOnly = await prisma.foro.findMany({ select: { idForo: true } })
     * 
    **/
    findMany<T extends FindManyForoArgs>(
      args?: Subset<T, FindManyForoArgs>
    ): CheckSelect<T, Promise<Array<Foro>>, Promise<Array<ForoGetPayload<T>>>>

    /**
     * Create a Foro.
     * @param {ForoCreateArgs} args - Arguments to create a Foro.
     * @example
     * // Create one Foro
     * const Foro = await prisma.foro.create({
     *   data: {
     *     // ... data to create a Foro
     *   }
     * })
     * 
    **/
    create<T extends ForoCreateArgs>(
      args: Subset<T, ForoCreateArgs>
    ): CheckSelect<T, Prisma__ForoClient<Foro>, Prisma__ForoClient<ForoGetPayload<T>>>

    /**
     * Delete a Foro.
     * @param {ForoDeleteArgs} args - Arguments to delete one Foro.
     * @example
     * // Delete one Foro
     * const Foro = await prisma.foro.delete({
     *   where: {
     *     // ... filter to delete one Foro
     *   }
     * })
     * 
    **/
    delete<T extends ForoDeleteArgs>(
      args: Subset<T, ForoDeleteArgs>
    ): CheckSelect<T, Prisma__ForoClient<Foro>, Prisma__ForoClient<ForoGetPayload<T>>>

    /**
     * Update one Foro.
     * @param {ForoUpdateArgs} args - Arguments to update one Foro.
     * @example
     * // Update one Foro
     * const foro = await prisma.foro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ForoUpdateArgs>(
      args: Subset<T, ForoUpdateArgs>
    ): CheckSelect<T, Prisma__ForoClient<Foro>, Prisma__ForoClient<ForoGetPayload<T>>>

    /**
     * Delete zero or more Foros.
     * @param {ForoDeleteManyArgs} args - Arguments to filter Foros to delete.
     * @example
     * // Delete a few Foros
     * const { count } = await prisma.foro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ForoDeleteManyArgs>(
      args?: Subset<T, ForoDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Foros.
     * @param {ForoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foros
     * const foro = await prisma.foro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ForoUpdateManyArgs>(
      args: Subset<T, ForoUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Foro.
     * @param {ForoUpsertArgs} args - Arguments to update or create a Foro.
     * @example
     * // Update or create a Foro
     * const foro = await prisma.foro.upsert({
     *   create: {
     *     // ... data to create a Foro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foro we want to update
     *   }
     * })
    **/
    upsert<T extends ForoUpsertArgs>(
      args: Subset<T, ForoUpsertArgs>
    ): CheckSelect<T, Prisma__ForoClient<Foro>, Prisma__ForoClient<ForoGetPayload<T>>>

    /**
     * Find zero or one Foro that matches the filter.
     * @param {FindUniqueForoArgs} args - Arguments to find a Foro
     * @deprecated This will be deprecated please use prisma.foro.findUnique
     * @example
     * // Get one Foro
     * const foro = await prisma.foro.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueForoArgs>(
      args: Subset<T, FindUniqueForoArgs>
    ): CheckSelect<T, Prisma__ForoClient<Foro | null>, Prisma__ForoClient<ForoGetPayload<T> | null>>

    /**
     * Count the number of Foros.
     * @param {FindManyForoArgs} args - Arguments to filter Foros to count.
     * @example
     * // Count the number of Foros
     * const count = await prisma.foro.count({
     *   where: {
     *     // ... the filter for the Foros we want to count
     *   }
     * })
    **/
    count(args?: Omit<FindManyForoArgs, 'select' | 'include'>): Promise<number>

    /**
     * Allows you to perform aggregations operations on a Foro.
     * @param {AggregateForoArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregateForoArgs>(args: Subset<T, AggregateForoArgs>): Promise<GetForoAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Foro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ForoClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Informacion<T extends FindManyInformacionArgs = {}>(args?: Subset<T, FindManyInformacionArgs>): CheckSelect<T, Promise<Array<Informacion>>, Promise<Array<InformacionGetPayload<T>>>>;

    Publicacion<T extends FindManyPublicacionArgs = {}>(args?: Subset<T, FindManyPublicacionArgs>): CheckSelect<T, Promise<Array<Publicacion>>, Promise<Array<PublicacionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Foro findUnique
   */
  export type FindUniqueForoArgs = {
    /**
     * Select specific fields to fetch from the Foro
    **/
    select?: ForoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ForoInclude | null
    /**
     * Filter, which Foro to fetch.
    **/
    where: ForoWhereUniqueInput
  }


  /**
   * Foro findFirst
   */
  export type FindFirstForoArgs = {
    /**
     * Select specific fields to fetch from the Foro
    **/
    select?: ForoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ForoInclude | null
    /**
     * Filter, which Foro to fetch.
    **/
    where?: ForoWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Foros to fetch.
    **/
    orderBy?: Enumerable<ForoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foros.
    **/
    cursor?: ForoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foros from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foros.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Foros.
    **/
    distinct?: Enumerable<ForoScalarFieldEnum>
  }


  /**
   * Foro findMany
   */
  export type FindManyForoArgs = {
    /**
     * Select specific fields to fetch from the Foro
    **/
    select?: ForoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ForoInclude | null
    /**
     * Filter, which Foros to fetch.
    **/
    where?: ForoWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Foros to fetch.
    **/
    orderBy?: Enumerable<ForoOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foros.
    **/
    cursor?: ForoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foros from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foros.
    **/
    skip?: number
    distinct?: Enumerable<ForoScalarFieldEnum>
  }


  /**
   * Foro create
   */
  export type ForoCreateArgs = {
    /**
     * Select specific fields to fetch from the Foro
    **/
    select?: ForoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ForoInclude | null
    /**
     * The data needed to create a Foro.
    **/
    data: ForoCreateInput
  }


  /**
   * Foro update
   */
  export type ForoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Foro
    **/
    select?: ForoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ForoInclude | null
    /**
     * The data needed to update a Foro.
    **/
    data: ForoUpdateInput
    /**
     * Choose, which Foro to update.
    **/
    where: ForoWhereUniqueInput
  }


  /**
   * Foro updateMany
   */
  export type ForoUpdateManyArgs = {
    data: ForoUpdateManyMutationInput
    where?: ForoWhereInput
  }


  /**
   * Foro upsert
   */
  export type ForoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Foro
    **/
    select?: ForoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ForoInclude | null
    /**
     * The filter to search for the Foro to update in case it exists.
    **/
    where: ForoWhereUniqueInput
    /**
     * In case the Foro found by the `where` argument doesn't exist, create a new Foro with this data.
    **/
    create: ForoCreateInput
    /**
     * In case the Foro was found with the provided `where` argument, update it with this data.
    **/
    update: ForoUpdateInput
  }


  /**
   * Foro delete
   */
  export type ForoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Foro
    **/
    select?: ForoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ForoInclude | null
    /**
     * Filter which Foro to delete.
    **/
    where: ForoWhereUniqueInput
  }


  /**
   * Foro deleteMany
   */
  export type ForoDeleteManyArgs = {
    where?: ForoWhereInput
  }


  /**
   * Foro without action
   */
  export type ForoArgs = {
    /**
     * Select specific fields to fetch from the Foro
    **/
    select?: ForoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ForoInclude | null
  }



  /**
   * Model Informacion
   */


  export type AggregateInformacion = {
    count: number | null
    avg: InformacionAvgAggregateOutputType | null
    sum: InformacionSumAggregateOutputType | null
    min: InformacionMinAggregateOutputType | null
    max: InformacionMaxAggregateOutputType | null
  }

  export type InformacionAvgAggregateOutputType = {
    idInformacion: number
    foro: number
  }

  export type InformacionSumAggregateOutputType = {
    idInformacion: number
    foro: number
  }

  export type InformacionMinAggregateOutputType = {
    idInformacion: number
    titulo: string | null
    contenido: string | null
    foro: number
  }

  export type InformacionMaxAggregateOutputType = {
    idInformacion: number
    titulo: string | null
    contenido: string | null
    foro: number
  }

  export type InformacionCountAggregateOutputType = {
    idInformacion: number
    titulo: number | null
    contenido: number | null
    foro: number
    _all: number
  }


  export type InformacionAvgAggregateInputType = {
    idInformacion?: true
    foro?: true
  }

  export type InformacionSumAggregateInputType = {
    idInformacion?: true
    foro?: true
  }

  export type InformacionMinAggregateInputType = {
    idInformacion?: true
    titulo?: true
    contenido?: true
    foro?: true
  }

  export type InformacionMaxAggregateInputType = {
    idInformacion?: true
    titulo?: true
    contenido?: true
    foro?: true
  }

  export type InformacionCountAggregateInputType = {
    idInformacion?: true
    titulo?: true
    contenido?: true
    foro?: true
    _all?: true
  }

  export type AggregateInformacionArgs = {
    /**
     * Filter which Informacion to aggregate.
    **/
    where?: InformacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Informacions to fetch.
    **/
    orderBy?: Enumerable<InformacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: InformacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Informacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Informacions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Informacions
    **/
    count?: true
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: InformacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: InformacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: InformacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: InformacionMaxAggregateInputType
  }

  export type GetInformacionAggregateType<T extends AggregateInformacionArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetInformacionAggregateScalarType<T[P]>
  }

  export type GetInformacionAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof InformacionAvgAggregateOutputType ? InformacionAvgAggregateOutputType[P] : never
  }

    



  export type InformacionSelect = {
    idInformacion?: boolean
    titulo?: boolean
    contenido?: boolean
    foro?: boolean
    Foro?: boolean | ForoArgs
  }

  export type InformacionInclude = {
    Foro?: boolean | ForoArgs
  }

  export type InformacionGetPayload<
    S extends boolean | null | undefined | InformacionArgs,
    U = keyof S
      > = S extends true
        ? Informacion
    : S extends undefined
    ? never
    : S extends InformacionArgs | FindManyInformacionArgs
    ?'include' extends U
    ? Informacion  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Foro'
        ? ForoGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Informacion ?Informacion [P]
  : 
          P extends 'Foro'
        ? ForoGetPayload<S['select'][P]> : never
  } 
    : Informacion
  : Informacion


  export interface InformacionDelegate {
    /**
     * Find zero or one Informacion that matches the filter.
     * @param {FindUniqueInformacionArgs} args - Arguments to find a Informacion
     * @example
     * // Get one Informacion
     * const informacion = await prisma.informacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniqueInformacionArgs>(
      args: Subset<T, FindUniqueInformacionArgs>
    ): CheckSelect<T, Prisma__InformacionClient<Informacion | null>, Prisma__InformacionClient<InformacionGetPayload<T> | null>>

    /**
     * Find the first Informacion that matches the filter.
     * @param {FindFirstInformacionArgs} args - Arguments to find a Informacion
     * @example
     * // Get one Informacion
     * const informacion = await prisma.informacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstInformacionArgs>(
      args?: Subset<T, FindFirstInformacionArgs>
    ): CheckSelect<T, Prisma__InformacionClient<Informacion | null>, Prisma__InformacionClient<InformacionGetPayload<T> | null>>

    /**
     * Find zero or more Informacions that matches the filter.
     * @param {FindManyInformacionArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Informacions
     * const informacions = await prisma.informacion.findMany()
     * 
     * // Get first 10 Informacions
     * const informacions = await prisma.informacion.findMany({ take: 10 })
     * 
     * // Only select the `idInformacion`
     * const informacionWithIdInformacionOnly = await prisma.informacion.findMany({ select: { idInformacion: true } })
     * 
    **/
    findMany<T extends FindManyInformacionArgs>(
      args?: Subset<T, FindManyInformacionArgs>
    ): CheckSelect<T, Promise<Array<Informacion>>, Promise<Array<InformacionGetPayload<T>>>>

    /**
     * Create a Informacion.
     * @param {InformacionCreateArgs} args - Arguments to create a Informacion.
     * @example
     * // Create one Informacion
     * const Informacion = await prisma.informacion.create({
     *   data: {
     *     // ... data to create a Informacion
     *   }
     * })
     * 
    **/
    create<T extends InformacionCreateArgs>(
      args: Subset<T, InformacionCreateArgs>
    ): CheckSelect<T, Prisma__InformacionClient<Informacion>, Prisma__InformacionClient<InformacionGetPayload<T>>>

    /**
     * Delete a Informacion.
     * @param {InformacionDeleteArgs} args - Arguments to delete one Informacion.
     * @example
     * // Delete one Informacion
     * const Informacion = await prisma.informacion.delete({
     *   where: {
     *     // ... filter to delete one Informacion
     *   }
     * })
     * 
    **/
    delete<T extends InformacionDeleteArgs>(
      args: Subset<T, InformacionDeleteArgs>
    ): CheckSelect<T, Prisma__InformacionClient<Informacion>, Prisma__InformacionClient<InformacionGetPayload<T>>>

    /**
     * Update one Informacion.
     * @param {InformacionUpdateArgs} args - Arguments to update one Informacion.
     * @example
     * // Update one Informacion
     * const informacion = await prisma.informacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InformacionUpdateArgs>(
      args: Subset<T, InformacionUpdateArgs>
    ): CheckSelect<T, Prisma__InformacionClient<Informacion>, Prisma__InformacionClient<InformacionGetPayload<T>>>

    /**
     * Delete zero or more Informacions.
     * @param {InformacionDeleteManyArgs} args - Arguments to filter Informacions to delete.
     * @example
     * // Delete a few Informacions
     * const { count } = await prisma.informacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InformacionDeleteManyArgs>(
      args?: Subset<T, InformacionDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Informacions.
     * @param {InformacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Informacions
     * const informacion = await prisma.informacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InformacionUpdateManyArgs>(
      args: Subset<T, InformacionUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Informacion.
     * @param {InformacionUpsertArgs} args - Arguments to update or create a Informacion.
     * @example
     * // Update or create a Informacion
     * const informacion = await prisma.informacion.upsert({
     *   create: {
     *     // ... data to create a Informacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Informacion we want to update
     *   }
     * })
    **/
    upsert<T extends InformacionUpsertArgs>(
      args: Subset<T, InformacionUpsertArgs>
    ): CheckSelect<T, Prisma__InformacionClient<Informacion>, Prisma__InformacionClient<InformacionGetPayload<T>>>

    /**
     * Find zero or one Informacion that matches the filter.
     * @param {FindUniqueInformacionArgs} args - Arguments to find a Informacion
     * @deprecated This will be deprecated please use prisma.informacion.findUnique
     * @example
     * // Get one Informacion
     * const informacion = await prisma.informacion.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniqueInformacionArgs>(
      args: Subset<T, FindUniqueInformacionArgs>
    ): CheckSelect<T, Prisma__InformacionClient<Informacion | null>, Prisma__InformacionClient<InformacionGetPayload<T> | null>>

    /**
     * Count the number of Informacions.
     * @param {FindManyInformacionArgs} args - Arguments to filter Informacions to count.
     * @example
     * // Count the number of Informacions
     * const count = await prisma.informacion.count({
     *   where: {
     *     // ... the filter for the Informacions we want to count
     *   }
     * })
    **/
    count(args?: Omit<FindManyInformacionArgs, 'select' | 'include'>): Promise<number>

    /**
     * Allows you to perform aggregations operations on a Informacion.
     * @param {AggregateInformacionArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregateInformacionArgs>(args: Subset<T, AggregateInformacionArgs>): Promise<GetInformacionAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Informacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InformacionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Foro<T extends ForoArgs = {}>(args?: Subset<T, ForoArgs>): CheckSelect<T, Prisma__ForoClient<Foro | null>, Prisma__ForoClient<ForoGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Informacion findUnique
   */
  export type FindUniqueInformacionArgs = {
    /**
     * Select specific fields to fetch from the Informacion
    **/
    select?: InformacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: InformacionInclude | null
    /**
     * Filter, which Informacion to fetch.
    **/
    where: InformacionWhereUniqueInput
  }


  /**
   * Informacion findFirst
   */
  export type FindFirstInformacionArgs = {
    /**
     * Select specific fields to fetch from the Informacion
    **/
    select?: InformacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: InformacionInclude | null
    /**
     * Filter, which Informacion to fetch.
    **/
    where?: InformacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Informacions to fetch.
    **/
    orderBy?: Enumerable<InformacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Informacions.
    **/
    cursor?: InformacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Informacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Informacions.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Informacions.
    **/
    distinct?: Enumerable<InformacionScalarFieldEnum>
  }


  /**
   * Informacion findMany
   */
  export type FindManyInformacionArgs = {
    /**
     * Select specific fields to fetch from the Informacion
    **/
    select?: InformacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: InformacionInclude | null
    /**
     * Filter, which Informacions to fetch.
    **/
    where?: InformacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Informacions to fetch.
    **/
    orderBy?: Enumerable<InformacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Informacions.
    **/
    cursor?: InformacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Informacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Informacions.
    **/
    skip?: number
    distinct?: Enumerable<InformacionScalarFieldEnum>
  }


  /**
   * Informacion create
   */
  export type InformacionCreateArgs = {
    /**
     * Select specific fields to fetch from the Informacion
    **/
    select?: InformacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: InformacionInclude | null
    /**
     * The data needed to create a Informacion.
    **/
    data: InformacionCreateInput
  }


  /**
   * Informacion update
   */
  export type InformacionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Informacion
    **/
    select?: InformacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: InformacionInclude | null
    /**
     * The data needed to update a Informacion.
    **/
    data: InformacionUpdateInput
    /**
     * Choose, which Informacion to update.
    **/
    where: InformacionWhereUniqueInput
  }


  /**
   * Informacion updateMany
   */
  export type InformacionUpdateManyArgs = {
    data: InformacionUpdateManyMutationInput
    where?: InformacionWhereInput
  }


  /**
   * Informacion upsert
   */
  export type InformacionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Informacion
    **/
    select?: InformacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: InformacionInclude | null
    /**
     * The filter to search for the Informacion to update in case it exists.
    **/
    where: InformacionWhereUniqueInput
    /**
     * In case the Informacion found by the `where` argument doesn't exist, create a new Informacion with this data.
    **/
    create: InformacionCreateInput
    /**
     * In case the Informacion was found with the provided `where` argument, update it with this data.
    **/
    update: InformacionUpdateInput
  }


  /**
   * Informacion delete
   */
  export type InformacionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Informacion
    **/
    select?: InformacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: InformacionInclude | null
    /**
     * Filter which Informacion to delete.
    **/
    where: InformacionWhereUniqueInput
  }


  /**
   * Informacion deleteMany
   */
  export type InformacionDeleteManyArgs = {
    where?: InformacionWhereInput
  }


  /**
   * Informacion without action
   */
  export type InformacionArgs = {
    /**
     * Select specific fields to fetch from the Informacion
    **/
    select?: InformacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: InformacionInclude | null
  }



  /**
   * Model Publicacion
   */


  export type AggregatePublicacion = {
    count: number | null
    avg: PublicacionAvgAggregateOutputType | null
    sum: PublicacionSumAggregateOutputType | null
    min: PublicacionMinAggregateOutputType | null
    max: PublicacionMaxAggregateOutputType | null
  }

  export type PublicacionAvgAggregateOutputType = {
    idPublicacion: number
    foro: number
    usuario: number
  }

  export type PublicacionSumAggregateOutputType = {
    idPublicacion: number
    foro: number
    usuario: number
  }

  export type PublicacionMinAggregateOutputType = {
    idPublicacion: number
    fecha: Date | null
    contenido: string | null
    foro: number
    usuario: number
  }

  export type PublicacionMaxAggregateOutputType = {
    idPublicacion: number
    fecha: Date | null
    contenido: string | null
    foro: number
    usuario: number
  }

  export type PublicacionCountAggregateOutputType = {
    idPublicacion: number
    fecha: number | null
    contenido: number | null
    foro: number
    usuario: number
    _all: number
  }


  export type PublicacionAvgAggregateInputType = {
    idPublicacion?: true
    foro?: true
    usuario?: true
  }

  export type PublicacionSumAggregateInputType = {
    idPublicacion?: true
    foro?: true
    usuario?: true
  }

  export type PublicacionMinAggregateInputType = {
    idPublicacion?: true
    fecha?: true
    contenido?: true
    foro?: true
    usuario?: true
  }

  export type PublicacionMaxAggregateInputType = {
    idPublicacion?: true
    fecha?: true
    contenido?: true
    foro?: true
    usuario?: true
  }

  export type PublicacionCountAggregateInputType = {
    idPublicacion?: true
    fecha?: true
    contenido?: true
    foro?: true
    usuario?: true
    _all?: true
  }

  export type AggregatePublicacionArgs = {
    /**
     * Filter which Publicacion to aggregate.
    **/
    where?: PublicacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Publicacions to fetch.
    **/
    orderBy?: Enumerable<PublicacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PublicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publicacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publicacions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publicacions
    **/
    count?: true
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PublicacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PublicacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PublicacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PublicacionMaxAggregateInputType
  }

  export type GetPublicacionAggregateType<T extends AggregatePublicacionArgs> = {
    [P in keyof T]: P extends 'count' ? number : GetPublicacionAggregateScalarType<T[P]>
  }

  export type GetPublicacionAggregateScalarType<T extends any> = {
    [P in keyof T]: P extends keyof PublicacionAvgAggregateOutputType ? PublicacionAvgAggregateOutputType[P] : never
  }

    



  export type PublicacionSelect = {
    idPublicacion?: boolean
    fecha?: boolean
    contenido?: boolean
    foro?: boolean
    usuario?: boolean
    Foro?: boolean | ForoArgs
    Usuario?: boolean | UsuarioArgs
  }

  export type PublicacionInclude = {
    Foro?: boolean | ForoArgs
    Usuario?: boolean | UsuarioArgs
  }

  export type PublicacionGetPayload<
    S extends boolean | null | undefined | PublicacionArgs,
    U = keyof S
      > = S extends true
        ? Publicacion
    : S extends undefined
    ? never
    : S extends PublicacionArgs | FindManyPublicacionArgs
    ?'include' extends U
    ? Publicacion  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'Foro'
        ? ForoGetPayload<S['include'][P]> :
        P extends 'Usuario'
        ? UsuarioGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Publicacion ?Publicacion [P]
  : 
          P extends 'Foro'
        ? ForoGetPayload<S['select'][P]> :
        P extends 'Usuario'
        ? UsuarioGetPayload<S['select'][P]> : never
  } 
    : Publicacion
  : Publicacion


  export interface PublicacionDelegate {
    /**
     * Find zero or one Publicacion that matches the filter.
     * @param {FindUniquePublicacionArgs} args - Arguments to find a Publicacion
     * @example
     * // Get one Publicacion
     * const publicacion = await prisma.publicacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FindUniquePublicacionArgs>(
      args: Subset<T, FindUniquePublicacionArgs>
    ): CheckSelect<T, Prisma__PublicacionClient<Publicacion | null>, Prisma__PublicacionClient<PublicacionGetPayload<T> | null>>

    /**
     * Find the first Publicacion that matches the filter.
     * @param {FindFirstPublicacionArgs} args - Arguments to find a Publicacion
     * @example
     * // Get one Publicacion
     * const publicacion = await prisma.publicacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FindFirstPublicacionArgs>(
      args?: Subset<T, FindFirstPublicacionArgs>
    ): CheckSelect<T, Prisma__PublicacionClient<Publicacion | null>, Prisma__PublicacionClient<PublicacionGetPayload<T> | null>>

    /**
     * Find zero or more Publicacions that matches the filter.
     * @param {FindManyPublicacionArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publicacions
     * const publicacions = await prisma.publicacion.findMany()
     * 
     * // Get first 10 Publicacions
     * const publicacions = await prisma.publicacion.findMany({ take: 10 })
     * 
     * // Only select the `idPublicacion`
     * const publicacionWithIdPublicacionOnly = await prisma.publicacion.findMany({ select: { idPublicacion: true } })
     * 
    **/
    findMany<T extends FindManyPublicacionArgs>(
      args?: Subset<T, FindManyPublicacionArgs>
    ): CheckSelect<T, Promise<Array<Publicacion>>, Promise<Array<PublicacionGetPayload<T>>>>

    /**
     * Create a Publicacion.
     * @param {PublicacionCreateArgs} args - Arguments to create a Publicacion.
     * @example
     * // Create one Publicacion
     * const Publicacion = await prisma.publicacion.create({
     *   data: {
     *     // ... data to create a Publicacion
     *   }
     * })
     * 
    **/
    create<T extends PublicacionCreateArgs>(
      args: Subset<T, PublicacionCreateArgs>
    ): CheckSelect<T, Prisma__PublicacionClient<Publicacion>, Prisma__PublicacionClient<PublicacionGetPayload<T>>>

    /**
     * Delete a Publicacion.
     * @param {PublicacionDeleteArgs} args - Arguments to delete one Publicacion.
     * @example
     * // Delete one Publicacion
     * const Publicacion = await prisma.publicacion.delete({
     *   where: {
     *     // ... filter to delete one Publicacion
     *   }
     * })
     * 
    **/
    delete<T extends PublicacionDeleteArgs>(
      args: Subset<T, PublicacionDeleteArgs>
    ): CheckSelect<T, Prisma__PublicacionClient<Publicacion>, Prisma__PublicacionClient<PublicacionGetPayload<T>>>

    /**
     * Update one Publicacion.
     * @param {PublicacionUpdateArgs} args - Arguments to update one Publicacion.
     * @example
     * // Update one Publicacion
     * const publicacion = await prisma.publicacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PublicacionUpdateArgs>(
      args: Subset<T, PublicacionUpdateArgs>
    ): CheckSelect<T, Prisma__PublicacionClient<Publicacion>, Prisma__PublicacionClient<PublicacionGetPayload<T>>>

    /**
     * Delete zero or more Publicacions.
     * @param {PublicacionDeleteManyArgs} args - Arguments to filter Publicacions to delete.
     * @example
     * // Delete a few Publicacions
     * const { count } = await prisma.publicacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PublicacionDeleteManyArgs>(
      args?: Subset<T, PublicacionDeleteManyArgs>
    ): Promise<BatchPayload>

    /**
     * Update zero or more Publicacions.
     * @param {PublicacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publicacions
     * const publicacion = await prisma.publicacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PublicacionUpdateManyArgs>(
      args: Subset<T, PublicacionUpdateManyArgs>
    ): Promise<BatchPayload>

    /**
     * Create or update one Publicacion.
     * @param {PublicacionUpsertArgs} args - Arguments to update or create a Publicacion.
     * @example
     * // Update or create a Publicacion
     * const publicacion = await prisma.publicacion.upsert({
     *   create: {
     *     // ... data to create a Publicacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publicacion we want to update
     *   }
     * })
    **/
    upsert<T extends PublicacionUpsertArgs>(
      args: Subset<T, PublicacionUpsertArgs>
    ): CheckSelect<T, Prisma__PublicacionClient<Publicacion>, Prisma__PublicacionClient<PublicacionGetPayload<T>>>

    /**
     * Find zero or one Publicacion that matches the filter.
     * @param {FindUniquePublicacionArgs} args - Arguments to find a Publicacion
     * @deprecated This will be deprecated please use prisma.publicacion.findUnique
     * @example
     * // Get one Publicacion
     * const publicacion = await prisma.publicacion.findOne({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findOne<T extends FindUniquePublicacionArgs>(
      args: Subset<T, FindUniquePublicacionArgs>
    ): CheckSelect<T, Prisma__PublicacionClient<Publicacion | null>, Prisma__PublicacionClient<PublicacionGetPayload<T> | null>>

    /**
     * Count the number of Publicacions.
     * @param {FindManyPublicacionArgs} args - Arguments to filter Publicacions to count.
     * @example
     * // Count the number of Publicacions
     * const count = await prisma.publicacion.count({
     *   where: {
     *     // ... the filter for the Publicacions we want to count
     *   }
     * })
    **/
    count(args?: Omit<FindManyPublicacionArgs, 'select' | 'include'>): Promise<number>

    /**
     * Allows you to perform aggregations operations on a Publicacion.
     * @param {AggregatePublicacionArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AggregatePublicacionArgs>(args: Subset<T, AggregatePublicacionArgs>): Promise<GetPublicacionAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Publicacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PublicacionClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Foro<T extends ForoArgs = {}>(args?: Subset<T, ForoArgs>): CheckSelect<T, Prisma__ForoClient<Foro | null>, Prisma__ForoClient<ForoGetPayload<T> | null>>;

    Usuario<T extends UsuarioArgs = {}>(args?: Subset<T, UsuarioArgs>): CheckSelect<T, Prisma__UsuarioClient<Usuario | null>, Prisma__UsuarioClient<UsuarioGetPayload<T> | null>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Publicacion findUnique
   */
  export type FindUniquePublicacionArgs = {
    /**
     * Select specific fields to fetch from the Publicacion
    **/
    select?: PublicacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublicacionInclude | null
    /**
     * Filter, which Publicacion to fetch.
    **/
    where: PublicacionWhereUniqueInput
  }


  /**
   * Publicacion findFirst
   */
  export type FindFirstPublicacionArgs = {
    /**
     * Select specific fields to fetch from the Publicacion
    **/
    select?: PublicacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublicacionInclude | null
    /**
     * Filter, which Publicacion to fetch.
    **/
    where?: PublicacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Publicacions to fetch.
    **/
    orderBy?: Enumerable<PublicacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publicacions.
    **/
    cursor?: PublicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publicacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publicacions.
    **/
    skip?: number
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs
     * 
     * Filter by unique combinations of Publicacions.
    **/
    distinct?: Enumerable<PublicacionScalarFieldEnum>
  }


  /**
   * Publicacion findMany
   */
  export type FindManyPublicacionArgs = {
    /**
     * Select specific fields to fetch from the Publicacion
    **/
    select?: PublicacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublicacionInclude | null
    /**
     * Filter, which Publicacions to fetch.
    **/
    where?: PublicacionWhereInput
    /**
     * @link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs
     * 
     * Determine the order of Publicacions to fetch.
    **/
    orderBy?: Enumerable<PublicacionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publicacions.
    **/
    cursor?: PublicacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publicacions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publicacions.
    **/
    skip?: number
    distinct?: Enumerable<PublicacionScalarFieldEnum>
  }


  /**
   * Publicacion create
   */
  export type PublicacionCreateArgs = {
    /**
     * Select specific fields to fetch from the Publicacion
    **/
    select?: PublicacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublicacionInclude | null
    /**
     * The data needed to create a Publicacion.
    **/
    data: PublicacionCreateInput
  }


  /**
   * Publicacion update
   */
  export type PublicacionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Publicacion
    **/
    select?: PublicacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublicacionInclude | null
    /**
     * The data needed to update a Publicacion.
    **/
    data: PublicacionUpdateInput
    /**
     * Choose, which Publicacion to update.
    **/
    where: PublicacionWhereUniqueInput
  }


  /**
   * Publicacion updateMany
   */
  export type PublicacionUpdateManyArgs = {
    data: PublicacionUpdateManyMutationInput
    where?: PublicacionWhereInput
  }


  /**
   * Publicacion upsert
   */
  export type PublicacionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Publicacion
    **/
    select?: PublicacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublicacionInclude | null
    /**
     * The filter to search for the Publicacion to update in case it exists.
    **/
    where: PublicacionWhereUniqueInput
    /**
     * In case the Publicacion found by the `where` argument doesn't exist, create a new Publicacion with this data.
    **/
    create: PublicacionCreateInput
    /**
     * In case the Publicacion was found with the provided `where` argument, update it with this data.
    **/
    update: PublicacionUpdateInput
  }


  /**
   * Publicacion delete
   */
  export type PublicacionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Publicacion
    **/
    select?: PublicacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublicacionInclude | null
    /**
     * Filter which Publicacion to delete.
    **/
    where: PublicacionWhereUniqueInput
  }


  /**
   * Publicacion deleteMany
   */
  export type PublicacionDeleteManyArgs = {
    where?: PublicacionWhereInput
  }


  /**
   * Publicacion without action
   */
  export type PublicacionArgs = {
    /**
     * Select specific fields to fetch from the Publicacion
    **/
    select?: PublicacionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublicacionInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UsuarioScalarFieldEnum: {
    idUsuario: 'idUsuario',
    usuario: 'usuario',
    pass: 'pass',
    matricula: 'matricula'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const EstacionScalarFieldEnum: {
    idEstacion: 'idEstacion',
    nombre: 'nombre'
  };

  export type EstacionScalarFieldEnum = (typeof EstacionScalarFieldEnum)[keyof typeof EstacionScalarFieldEnum]


  export const BicicletaScalarFieldEnum: {
    idBicicleta: 'idBicicleta',
    estado: 'estado',
    estacion: 'estacion'
  };

  export type BicicletaScalarFieldEnum = (typeof BicicletaScalarFieldEnum)[keyof typeof BicicletaScalarFieldEnum]


  export const AlquilerScalarFieldEnum: {
    idAlquiler: 'idAlquiler',
    usuario: 'usuario',
    bicicleta: 'bicicleta',
    fecha: 'fecha',
    estado: 'estado'
  };

  export type AlquilerScalarFieldEnum = (typeof AlquilerScalarFieldEnum)[keyof typeof AlquilerScalarFieldEnum]


  export const ReportarScalarFieldEnum: {
    idReportar: 'idReportar',
    usuario: 'usuario',
    bicicleta: 'bicicleta',
    contenido: 'contenido',
    fecha: 'fecha',
    estado: 'estado'
  };

  export type ReportarScalarFieldEnum = (typeof ReportarScalarFieldEnum)[keyof typeof ReportarScalarFieldEnum]


  export const ForoScalarFieldEnum: {
    idForo: 'idForo',
    descripcion: 'descripcion'
  };

  export type ForoScalarFieldEnum = (typeof ForoScalarFieldEnum)[keyof typeof ForoScalarFieldEnum]


  export const InformacionScalarFieldEnum: {
    idInformacion: 'idInformacion',
    titulo: 'titulo',
    contenido: 'contenido',
    foro: 'foro'
  };

  export type InformacionScalarFieldEnum = (typeof InformacionScalarFieldEnum)[keyof typeof InformacionScalarFieldEnum]


  export const PublicacionScalarFieldEnum: {
    idPublicacion: 'idPublicacion',
    fecha: 'fecha',
    contenido: 'contenido',
    foro: 'foro',
    usuario: 'usuario'
  };

  export type PublicacionScalarFieldEnum = (typeof PublicacionScalarFieldEnum)[keyof typeof PublicacionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: Enumerable<UsuarioWhereInput>
    OR?: Enumerable<UsuarioWhereInput>
    NOT?: Enumerable<UsuarioWhereInput>
    idUsuario?: IntFilter | number
    usuario?: StringFilter | string
    pass?: StringFilter | string
    matricula?: IntFilter | number
    Alquiler?: AlquilerListRelationFilter
    Reportar?: ReportarListRelationFilter
    Publicacion?: PublicacionListRelationFilter
  }

  export type UsuarioOrderByInput = {
    idUsuario?: SortOrder
    usuario?: SortOrder
    pass?: SortOrder
    matricula?: SortOrder
  }

  export type UsuarioWhereUniqueInput = {
    idUsuario?: number
    matricula?: number
  }

  export type EstacionWhereInput = {
    AND?: Enumerable<EstacionWhereInput>
    OR?: Enumerable<EstacionWhereInput>
    NOT?: Enumerable<EstacionWhereInput>
    idEstacion?: IntFilter | number
    nombre?: StringFilter | string
    Bicicleta?: BicicletaListRelationFilter
  }

  export type EstacionOrderByInput = {
    idEstacion?: SortOrder
    nombre?: SortOrder
  }

  export type EstacionWhereUniqueInput = {
    idEstacion?: number
  }

  export type BicicletaWhereInput = {
    AND?: Enumerable<BicicletaWhereInput>
    OR?: Enumerable<BicicletaWhereInput>
    NOT?: Enumerable<BicicletaWhereInput>
    idBicicleta?: IntFilter | number
    estado?: StringFilter | string
    Estacion?: XOR<EstacionWhereInput, EstacionRelationFilter>
    estacion?: IntFilter | number
    Alquiler?: AlquilerListRelationFilter
    Reportar?: ReportarListRelationFilter
  }

  export type BicicletaOrderByInput = {
    idBicicleta?: SortOrder
    estado?: SortOrder
    estacion?: SortOrder
  }

  export type BicicletaWhereUniqueInput = {
    idBicicleta?: number
  }

  export type AlquilerWhereInput = {
    AND?: Enumerable<AlquilerWhereInput>
    OR?: Enumerable<AlquilerWhereInput>
    NOT?: Enumerable<AlquilerWhereInput>
    idAlquiler?: IntFilter | number
    usuario?: IntFilter | number
    bicicleta?: IntFilter | number
    fecha?: DateTimeFilter | Date | string
    Bicicleta?: XOR<BicicletaWhereInput, BicicletaRelationFilter>
    Usuario?: XOR<UsuarioWhereInput, UsuarioRelationFilter>
    estado?: BoolFilter | boolean
  }

  export type AlquilerOrderByInput = {
    idAlquiler?: SortOrder
    usuario?: SortOrder
    bicicleta?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type AlquilerWhereUniqueInput = {
    idAlquiler?: number
  }

  export type ReportarWhereInput = {
    AND?: Enumerable<ReportarWhereInput>
    OR?: Enumerable<ReportarWhereInput>
    NOT?: Enumerable<ReportarWhereInput>
    idReportar?: IntFilter | number
    usuario?: IntFilter | number
    bicicleta?: IntFilter | number
    contenido?: StringNullableFilter | string | null
    fecha?: DateTimeFilter | Date | string
    Bicicleta?: XOR<BicicletaWhereInput, BicicletaRelationFilter>
    Usuario?: XOR<UsuarioWhereInput, UsuarioRelationFilter>
    estado?: BoolFilter | boolean
  }

  export type ReportarOrderByInput = {
    idReportar?: SortOrder
    usuario?: SortOrder
    bicicleta?: SortOrder
    contenido?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type ReportarWhereUniqueInput = {
    idReportar?: number
  }

  export type ForoWhereInput = {
    AND?: Enumerable<ForoWhereInput>
    OR?: Enumerable<ForoWhereInput>
    NOT?: Enumerable<ForoWhereInput>
    idForo?: IntFilter | number
    descripcion?: StringNullableFilter | string | null
    Informacion?: InformacionListRelationFilter
    Publicacion?: PublicacionListRelationFilter
  }

  export type ForoOrderByInput = {
    idForo?: SortOrder
    descripcion?: SortOrder
  }

  export type ForoWhereUniqueInput = {
    idForo?: number
  }

  export type InformacionWhereInput = {
    AND?: Enumerable<InformacionWhereInput>
    OR?: Enumerable<InformacionWhereInput>
    NOT?: Enumerable<InformacionWhereInput>
    idInformacion?: IntFilter | number
    titulo?: StringFilter | string
    contenido?: StringNullableFilter | string | null
    foro?: IntFilter | number
    Foro?: XOR<ForoWhereInput, ForoRelationFilter>
  }

  export type InformacionOrderByInput = {
    idInformacion?: SortOrder
    titulo?: SortOrder
    contenido?: SortOrder
    foro?: SortOrder
  }

  export type InformacionWhereUniqueInput = {
    idInformacion?: number
  }

  export type PublicacionWhereInput = {
    AND?: Enumerable<PublicacionWhereInput>
    OR?: Enumerable<PublicacionWhereInput>
    NOT?: Enumerable<PublicacionWhereInput>
    idPublicacion?: IntFilter | number
    fecha?: DateTimeFilter | Date | string
    contenido?: StringNullableFilter | string | null
    foro?: IntFilter | number
    usuario?: IntFilter | number
    Foro?: XOR<ForoWhereInput, ForoRelationFilter>
    Usuario?: XOR<UsuarioWhereInput, UsuarioRelationFilter>
  }

  export type PublicacionOrderByInput = {
    idPublicacion?: SortOrder
    fecha?: SortOrder
    contenido?: SortOrder
    foro?: SortOrder
    usuario?: SortOrder
  }

  export type PublicacionWhereUniqueInput = {
    idPublicacion?: number
  }

  export type UsuarioCreateInput = {
    usuario: string
    pass: string
    matricula: number
    Alquiler?: AlquilerCreateManyWithoutUsuarioInput
    Reportar?: ReportarCreateManyWithoutUsuarioInput
    Publicacion?: PublicacionCreateManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    matricula?: IntFieldUpdateOperationsInput | number
    Alquiler?: AlquilerUpdateManyWithoutUsuarioInput
    Reportar?: ReportarUpdateManyWithoutUsuarioInput
    Publicacion?: PublicacionUpdateManyWithoutUsuarioInput
  }

  export type UsuarioUpdateManyMutationInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    matricula?: IntFieldUpdateOperationsInput | number
  }

  export type EstacionCreateInput = {
    nombre: string
    Bicicleta?: BicicletaCreateManyWithoutEstacionInput
  }

  export type EstacionUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    Bicicleta?: BicicletaUpdateManyWithoutEstacionInput
  }

  export type EstacionUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type BicicletaCreateInput = {
    estado: string
    Estacion: EstacionCreateOneWithoutBicicletaInput
    Alquiler?: AlquilerCreateManyWithoutBicicletaInput
    Reportar?: ReportarCreateManyWithoutBicicletaInput
  }

  export type BicicletaUpdateInput = {
    estado?: StringFieldUpdateOperationsInput | string
    Estacion?: EstacionUpdateOneRequiredWithoutBicicletaInput
    Alquiler?: AlquilerUpdateManyWithoutBicicletaInput
    Reportar?: ReportarUpdateManyWithoutBicicletaInput
  }

  export type BicicletaUpdateManyMutationInput = {
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AlquilerCreateInput = {
    fecha?: Date | string
    estado?: boolean
    Bicicleta: BicicletaCreateOneWithoutAlquilerInput
    Usuario: UsuarioCreateOneWithoutAlquilerInput
  }

  export type AlquilerUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Bicicleta?: BicicletaUpdateOneRequiredWithoutAlquilerInput
    Usuario?: UsuarioUpdateOneRequiredWithoutAlquilerInput
  }

  export type AlquilerUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReportarCreateInput = {
    contenido?: string | null
    fecha?: Date | string
    estado?: boolean
    Bicicleta: BicicletaCreateOneWithoutReportarInput
    Usuario: UsuarioCreateOneWithoutReportarInput
  }

  export type ReportarUpdateInput = {
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Bicicleta?: BicicletaUpdateOneRequiredWithoutReportarInput
    Usuario?: UsuarioUpdateOneRequiredWithoutReportarInput
  }

  export type ReportarUpdateManyMutationInput = {
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ForoCreateInput = {
    descripcion?: string | null
    Informacion?: InformacionCreateManyWithoutForoInput
    Publicacion?: PublicacionCreateManyWithoutForoInput
  }

  export type ForoUpdateInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Informacion?: InformacionUpdateManyWithoutForoInput
    Publicacion?: PublicacionUpdateManyWithoutForoInput
  }

  export type ForoUpdateManyMutationInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InformacionCreateInput = {
    titulo: string
    contenido?: string | null
    Foro: ForoCreateOneWithoutInformacionInput
  }

  export type InformacionUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
    Foro?: ForoUpdateOneRequiredWithoutInformacionInput
  }

  export type InformacionUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublicacionCreateInput = {
    fecha?: Date | string
    contenido?: string | null
    Foro: ForoCreateOneWithoutPublicacionInput
    Usuario: UsuarioCreateOneWithoutPublicacionInput
  }

  export type PublicacionUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
    Foro?: ForoUpdateOneRequiredWithoutPublicacionInput
    Usuario?: UsuarioUpdateOneRequiredWithoutPublicacionInput
  }

  export type PublicacionUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type AlquilerListRelationFilter = {
    every?: AlquilerWhereInput
    some?: AlquilerWhereInput
    none?: AlquilerWhereInput
  }

  export type ReportarListRelationFilter = {
    every?: ReportarWhereInput
    some?: ReportarWhereInput
    none?: ReportarWhereInput
  }

  export type PublicacionListRelationFilter = {
    every?: PublicacionWhereInput
    some?: PublicacionWhereInput
    none?: PublicacionWhereInput
  }

  export type BicicletaListRelationFilter = {
    every?: BicicletaWhereInput
    some?: BicicletaWhereInput
    none?: BicicletaWhereInput
  }

  export type EstacionRelationFilter = {
    is?: EstacionWhereInput
    isNot?: EstacionWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type BicicletaRelationFilter = {
    is?: BicicletaWhereInput
    isNot?: BicicletaWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type InformacionListRelationFilter = {
    every?: InformacionWhereInput
    some?: InformacionWhereInput
    none?: InformacionWhereInput
  }

  export type ForoRelationFilter = {
    is?: ForoWhereInput
    isNot?: ForoWhereInput
  }

  export type AlquilerCreateManyWithoutUsuarioInput = {
    create?: Enumerable<AlquilerCreateWithoutUsuarioInput>
    connect?: Enumerable<AlquilerWhereUniqueInput>
    connectOrCreate?: Enumerable<AlquilerCreateOrConnectWithoutUsuarioInput>
  }

  export type ReportarCreateManyWithoutUsuarioInput = {
    create?: Enumerable<ReportarCreateWithoutUsuarioInput>
    connect?: Enumerable<ReportarWhereUniqueInput>
    connectOrCreate?: Enumerable<ReportarCreateOrConnectWithoutUsuarioInput>
  }

  export type PublicacionCreateManyWithoutUsuarioInput = {
    create?: Enumerable<PublicacionCreateWithoutUsuarioInput>
    connect?: Enumerable<PublicacionWhereUniqueInput>
    connectOrCreate?: Enumerable<PublicacionCreateOrConnectWithoutUsuarioInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlquilerUpdateManyWithoutUsuarioInput = {
    create?: Enumerable<AlquilerCreateWithoutUsuarioInput>
    connect?: Enumerable<AlquilerWhereUniqueInput>
    set?: Enumerable<AlquilerWhereUniqueInput>
    disconnect?: Enumerable<AlquilerWhereUniqueInput>
    delete?: Enumerable<AlquilerWhereUniqueInput>
    update?: Enumerable<AlquilerUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<AlquilerUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<AlquilerScalarWhereInput>
    upsert?: Enumerable<AlquilerUpsertWithWhereUniqueWithoutUsuarioInput>
    connectOrCreate?: Enumerable<AlquilerCreateOrConnectWithoutUsuarioInput>
  }

  export type ReportarUpdateManyWithoutUsuarioInput = {
    create?: Enumerable<ReportarCreateWithoutUsuarioInput>
    connect?: Enumerable<ReportarWhereUniqueInput>
    set?: Enumerable<ReportarWhereUniqueInput>
    disconnect?: Enumerable<ReportarWhereUniqueInput>
    delete?: Enumerable<ReportarWhereUniqueInput>
    update?: Enumerable<ReportarUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<ReportarUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<ReportarScalarWhereInput>
    upsert?: Enumerable<ReportarUpsertWithWhereUniqueWithoutUsuarioInput>
    connectOrCreate?: Enumerable<ReportarCreateOrConnectWithoutUsuarioInput>
  }

  export type PublicacionUpdateManyWithoutUsuarioInput = {
    create?: Enumerable<PublicacionCreateWithoutUsuarioInput>
    connect?: Enumerable<PublicacionWhereUniqueInput>
    set?: Enumerable<PublicacionWhereUniqueInput>
    disconnect?: Enumerable<PublicacionWhereUniqueInput>
    delete?: Enumerable<PublicacionWhereUniqueInput>
    update?: Enumerable<PublicacionUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<PublicacionUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<PublicacionScalarWhereInput>
    upsert?: Enumerable<PublicacionUpsertWithWhereUniqueWithoutUsuarioInput>
    connectOrCreate?: Enumerable<PublicacionCreateOrConnectWithoutUsuarioInput>
  }

  export type BicicletaCreateManyWithoutEstacionInput = {
    create?: Enumerable<BicicletaCreateWithoutEstacionInput>
    connect?: Enumerable<BicicletaWhereUniqueInput>
    connectOrCreate?: Enumerable<BicicletaCreateOrConnectWithoutEstacionInput>
  }

  export type BicicletaUpdateManyWithoutEstacionInput = {
    create?: Enumerable<BicicletaCreateWithoutEstacionInput>
    connect?: Enumerable<BicicletaWhereUniqueInput>
    set?: Enumerable<BicicletaWhereUniqueInput>
    disconnect?: Enumerable<BicicletaWhereUniqueInput>
    delete?: Enumerable<BicicletaWhereUniqueInput>
    update?: Enumerable<BicicletaUpdateWithWhereUniqueWithoutEstacionInput>
    updateMany?: Enumerable<BicicletaUpdateManyWithWhereWithoutEstacionInput>
    deleteMany?: Enumerable<BicicletaScalarWhereInput>
    upsert?: Enumerable<BicicletaUpsertWithWhereUniqueWithoutEstacionInput>
    connectOrCreate?: Enumerable<BicicletaCreateOrConnectWithoutEstacionInput>
  }

  export type EstacionCreateOneWithoutBicicletaInput = {
    create?: EstacionCreateWithoutBicicletaInput
    connect?: EstacionWhereUniqueInput
    connectOrCreate?: EstacionCreateOrConnectWithoutBicicletaInput
  }

  export type AlquilerCreateManyWithoutBicicletaInput = {
    create?: Enumerable<AlquilerCreateWithoutBicicletaInput>
    connect?: Enumerable<AlquilerWhereUniqueInput>
    connectOrCreate?: Enumerable<AlquilerCreateOrConnectWithoutBicicletaInput>
  }

  export type ReportarCreateManyWithoutBicicletaInput = {
    create?: Enumerable<ReportarCreateWithoutBicicletaInput>
    connect?: Enumerable<ReportarWhereUniqueInput>
    connectOrCreate?: Enumerable<ReportarCreateOrConnectWithoutBicicletaInput>
  }

  export type EstacionUpdateOneRequiredWithoutBicicletaInput = {
    create?: EstacionCreateWithoutBicicletaInput
    connect?: EstacionWhereUniqueInput
    update?: EstacionUpdateWithoutBicicletaInput
    upsert?: EstacionUpsertWithoutBicicletaInput
    connectOrCreate?: EstacionCreateOrConnectWithoutBicicletaInput
  }

  export type AlquilerUpdateManyWithoutBicicletaInput = {
    create?: Enumerable<AlquilerCreateWithoutBicicletaInput>
    connect?: Enumerable<AlquilerWhereUniqueInput>
    set?: Enumerable<AlquilerWhereUniqueInput>
    disconnect?: Enumerable<AlquilerWhereUniqueInput>
    delete?: Enumerable<AlquilerWhereUniqueInput>
    update?: Enumerable<AlquilerUpdateWithWhereUniqueWithoutBicicletaInput>
    updateMany?: Enumerable<AlquilerUpdateManyWithWhereWithoutBicicletaInput>
    deleteMany?: Enumerable<AlquilerScalarWhereInput>
    upsert?: Enumerable<AlquilerUpsertWithWhereUniqueWithoutBicicletaInput>
    connectOrCreate?: Enumerable<AlquilerCreateOrConnectWithoutBicicletaInput>
  }

  export type ReportarUpdateManyWithoutBicicletaInput = {
    create?: Enumerable<ReportarCreateWithoutBicicletaInput>
    connect?: Enumerable<ReportarWhereUniqueInput>
    set?: Enumerable<ReportarWhereUniqueInput>
    disconnect?: Enumerable<ReportarWhereUniqueInput>
    delete?: Enumerable<ReportarWhereUniqueInput>
    update?: Enumerable<ReportarUpdateWithWhereUniqueWithoutBicicletaInput>
    updateMany?: Enumerable<ReportarUpdateManyWithWhereWithoutBicicletaInput>
    deleteMany?: Enumerable<ReportarScalarWhereInput>
    upsert?: Enumerable<ReportarUpsertWithWhereUniqueWithoutBicicletaInput>
    connectOrCreate?: Enumerable<ReportarCreateOrConnectWithoutBicicletaInput>
  }

  export type BicicletaCreateOneWithoutAlquilerInput = {
    create?: BicicletaCreateWithoutAlquilerInput
    connect?: BicicletaWhereUniqueInput
    connectOrCreate?: BicicletaCreateOrConnectWithoutAlquilerInput
  }

  export type UsuarioCreateOneWithoutAlquilerInput = {
    create?: UsuarioCreateWithoutAlquilerInput
    connect?: UsuarioWhereUniqueInput
    connectOrCreate?: UsuarioCreateOrConnectWithoutAlquilerInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BicicletaUpdateOneRequiredWithoutAlquilerInput = {
    create?: BicicletaCreateWithoutAlquilerInput
    connect?: BicicletaWhereUniqueInput
    update?: BicicletaUpdateWithoutAlquilerInput
    upsert?: BicicletaUpsertWithoutAlquilerInput
    connectOrCreate?: BicicletaCreateOrConnectWithoutAlquilerInput
  }

  export type UsuarioUpdateOneRequiredWithoutAlquilerInput = {
    create?: UsuarioCreateWithoutAlquilerInput
    connect?: UsuarioWhereUniqueInput
    update?: UsuarioUpdateWithoutAlquilerInput
    upsert?: UsuarioUpsertWithoutAlquilerInput
    connectOrCreate?: UsuarioCreateOrConnectWithoutAlquilerInput
  }

  export type BicicletaCreateOneWithoutReportarInput = {
    create?: BicicletaCreateWithoutReportarInput
    connect?: BicicletaWhereUniqueInput
    connectOrCreate?: BicicletaCreateOrConnectWithoutReportarInput
  }

  export type UsuarioCreateOneWithoutReportarInput = {
    create?: UsuarioCreateWithoutReportarInput
    connect?: UsuarioWhereUniqueInput
    connectOrCreate?: UsuarioCreateOrConnectWithoutReportarInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BicicletaUpdateOneRequiredWithoutReportarInput = {
    create?: BicicletaCreateWithoutReportarInput
    connect?: BicicletaWhereUniqueInput
    update?: BicicletaUpdateWithoutReportarInput
    upsert?: BicicletaUpsertWithoutReportarInput
    connectOrCreate?: BicicletaCreateOrConnectWithoutReportarInput
  }

  export type UsuarioUpdateOneRequiredWithoutReportarInput = {
    create?: UsuarioCreateWithoutReportarInput
    connect?: UsuarioWhereUniqueInput
    update?: UsuarioUpdateWithoutReportarInput
    upsert?: UsuarioUpsertWithoutReportarInput
    connectOrCreate?: UsuarioCreateOrConnectWithoutReportarInput
  }

  export type InformacionCreateManyWithoutForoInput = {
    create?: Enumerable<InformacionCreateWithoutForoInput>
    connect?: Enumerable<InformacionWhereUniqueInput>
    connectOrCreate?: Enumerable<InformacionCreateOrConnectWithoutForoInput>
  }

  export type PublicacionCreateManyWithoutForoInput = {
    create?: Enumerable<PublicacionCreateWithoutForoInput>
    connect?: Enumerable<PublicacionWhereUniqueInput>
    connectOrCreate?: Enumerable<PublicacionCreateOrConnectWithoutForoInput>
  }

  export type InformacionUpdateManyWithoutForoInput = {
    create?: Enumerable<InformacionCreateWithoutForoInput>
    connect?: Enumerable<InformacionWhereUniqueInput>
    set?: Enumerable<InformacionWhereUniqueInput>
    disconnect?: Enumerable<InformacionWhereUniqueInput>
    delete?: Enumerable<InformacionWhereUniqueInput>
    update?: Enumerable<InformacionUpdateWithWhereUniqueWithoutForoInput>
    updateMany?: Enumerable<InformacionUpdateManyWithWhereWithoutForoInput>
    deleteMany?: Enumerable<InformacionScalarWhereInput>
    upsert?: Enumerable<InformacionUpsertWithWhereUniqueWithoutForoInput>
    connectOrCreate?: Enumerable<InformacionCreateOrConnectWithoutForoInput>
  }

  export type PublicacionUpdateManyWithoutForoInput = {
    create?: Enumerable<PublicacionCreateWithoutForoInput>
    connect?: Enumerable<PublicacionWhereUniqueInput>
    set?: Enumerable<PublicacionWhereUniqueInput>
    disconnect?: Enumerable<PublicacionWhereUniqueInput>
    delete?: Enumerable<PublicacionWhereUniqueInput>
    update?: Enumerable<PublicacionUpdateWithWhereUniqueWithoutForoInput>
    updateMany?: Enumerable<PublicacionUpdateManyWithWhereWithoutForoInput>
    deleteMany?: Enumerable<PublicacionScalarWhereInput>
    upsert?: Enumerable<PublicacionUpsertWithWhereUniqueWithoutForoInput>
    connectOrCreate?: Enumerable<PublicacionCreateOrConnectWithoutForoInput>
  }

  export type ForoCreateOneWithoutInformacionInput = {
    create?: ForoCreateWithoutInformacionInput
    connect?: ForoWhereUniqueInput
    connectOrCreate?: ForoCreateOrConnectWithoutInformacionInput
  }

  export type ForoUpdateOneRequiredWithoutInformacionInput = {
    create?: ForoCreateWithoutInformacionInput
    connect?: ForoWhereUniqueInput
    update?: ForoUpdateWithoutInformacionInput
    upsert?: ForoUpsertWithoutInformacionInput
    connectOrCreate?: ForoCreateOrConnectWithoutInformacionInput
  }

  export type ForoCreateOneWithoutPublicacionInput = {
    create?: ForoCreateWithoutPublicacionInput
    connect?: ForoWhereUniqueInput
    connectOrCreate?: ForoCreateOrConnectWithoutPublicacionInput
  }

  export type UsuarioCreateOneWithoutPublicacionInput = {
    create?: UsuarioCreateWithoutPublicacionInput
    connect?: UsuarioWhereUniqueInput
    connectOrCreate?: UsuarioCreateOrConnectWithoutPublicacionInput
  }

  export type ForoUpdateOneRequiredWithoutPublicacionInput = {
    create?: ForoCreateWithoutPublicacionInput
    connect?: ForoWhereUniqueInput
    update?: ForoUpdateWithoutPublicacionInput
    upsert?: ForoUpsertWithoutPublicacionInput
    connectOrCreate?: ForoCreateOrConnectWithoutPublicacionInput
  }

  export type UsuarioUpdateOneRequiredWithoutPublicacionInput = {
    create?: UsuarioCreateWithoutPublicacionInput
    connect?: UsuarioWhereUniqueInput
    update?: UsuarioUpdateWithoutPublicacionInput
    upsert?: UsuarioUpsertWithoutPublicacionInput
    connectOrCreate?: UsuarioCreateOrConnectWithoutPublicacionInput
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type AlquilerCreateWithoutUsuarioInput = {
    fecha?: Date | string
    estado?: boolean
    Bicicleta: BicicletaCreateOneWithoutAlquilerInput
  }

  export type AlquilerCreateOrConnectWithoutUsuarioInput = {
    where: AlquilerWhereUniqueInput
    create: AlquilerCreateWithoutUsuarioInput
  }

  export type ReportarCreateWithoutUsuarioInput = {
    contenido?: string | null
    fecha?: Date | string
    estado?: boolean
    Bicicleta: BicicletaCreateOneWithoutReportarInput
  }

  export type ReportarCreateOrConnectWithoutUsuarioInput = {
    where: ReportarWhereUniqueInput
    create: ReportarCreateWithoutUsuarioInput
  }

  export type PublicacionCreateWithoutUsuarioInput = {
    fecha?: Date | string
    contenido?: string | null
    Foro: ForoCreateOneWithoutPublicacionInput
  }

  export type PublicacionCreateOrConnectWithoutUsuarioInput = {
    where: PublicacionWhereUniqueInput
    create: PublicacionCreateWithoutUsuarioInput
  }

  export type AlquilerUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: AlquilerWhereUniqueInput
    data: AlquilerUpdateWithoutUsuarioInput
  }

  export type AlquilerUpdateManyWithWhereWithoutUsuarioInput = {
    where: AlquilerScalarWhereInput
    data: AlquilerUpdateManyMutationInput
  }

  export type AlquilerScalarWhereInput = {
    AND?: Enumerable<AlquilerScalarWhereInput>
    OR?: Enumerable<AlquilerScalarWhereInput>
    NOT?: Enumerable<AlquilerScalarWhereInput>
    idAlquiler?: IntFilter | number
    usuario?: IntFilter | number
    bicicleta?: IntFilter | number
    fecha?: DateTimeFilter | Date | string
    estado?: BoolFilter | boolean
  }

  export type AlquilerUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: AlquilerWhereUniqueInput
    update: AlquilerUpdateWithoutUsuarioInput
    create: AlquilerCreateWithoutUsuarioInput
  }

  export type ReportarUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ReportarWhereUniqueInput
    data: ReportarUpdateWithoutUsuarioInput
  }

  export type ReportarUpdateManyWithWhereWithoutUsuarioInput = {
    where: ReportarScalarWhereInput
    data: ReportarUpdateManyMutationInput
  }

  export type ReportarScalarWhereInput = {
    AND?: Enumerable<ReportarScalarWhereInput>
    OR?: Enumerable<ReportarScalarWhereInput>
    NOT?: Enumerable<ReportarScalarWhereInput>
    idReportar?: IntFilter | number
    usuario?: IntFilter | number
    bicicleta?: IntFilter | number
    contenido?: StringNullableFilter | string | null
    fecha?: DateTimeFilter | Date | string
    estado?: BoolFilter | boolean
  }

  export type ReportarUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ReportarWhereUniqueInput
    update: ReportarUpdateWithoutUsuarioInput
    create: ReportarCreateWithoutUsuarioInput
  }

  export type PublicacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PublicacionWhereUniqueInput
    data: PublicacionUpdateWithoutUsuarioInput
  }

  export type PublicacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: PublicacionScalarWhereInput
    data: PublicacionUpdateManyMutationInput
  }

  export type PublicacionScalarWhereInput = {
    AND?: Enumerable<PublicacionScalarWhereInput>
    OR?: Enumerable<PublicacionScalarWhereInput>
    NOT?: Enumerable<PublicacionScalarWhereInput>
    idPublicacion?: IntFilter | number
    fecha?: DateTimeFilter | Date | string
    contenido?: StringNullableFilter | string | null
    foro?: IntFilter | number
    usuario?: IntFilter | number
  }

  export type PublicacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PublicacionWhereUniqueInput
    update: PublicacionUpdateWithoutUsuarioInput
    create: PublicacionCreateWithoutUsuarioInput
  }

  export type BicicletaCreateWithoutEstacionInput = {
    estado: string
    Alquiler?: AlquilerCreateManyWithoutBicicletaInput
    Reportar?: ReportarCreateManyWithoutBicicletaInput
  }

  export type BicicletaCreateOrConnectWithoutEstacionInput = {
    where: BicicletaWhereUniqueInput
    create: BicicletaCreateWithoutEstacionInput
  }

  export type BicicletaUpdateWithWhereUniqueWithoutEstacionInput = {
    where: BicicletaWhereUniqueInput
    data: BicicletaUpdateWithoutEstacionInput
  }

  export type BicicletaUpdateManyWithWhereWithoutEstacionInput = {
    where: BicicletaScalarWhereInput
    data: BicicletaUpdateManyMutationInput
  }

  export type BicicletaScalarWhereInput = {
    AND?: Enumerable<BicicletaScalarWhereInput>
    OR?: Enumerable<BicicletaScalarWhereInput>
    NOT?: Enumerable<BicicletaScalarWhereInput>
    idBicicleta?: IntFilter | number
    estado?: StringFilter | string
    estacion?: IntFilter | number
  }

  export type BicicletaUpsertWithWhereUniqueWithoutEstacionInput = {
    where: BicicletaWhereUniqueInput
    update: BicicletaUpdateWithoutEstacionInput
    create: BicicletaCreateWithoutEstacionInput
  }

  export type EstacionCreateWithoutBicicletaInput = {
    nombre: string
  }

  export type EstacionCreateOrConnectWithoutBicicletaInput = {
    where: EstacionWhereUniqueInput
    create: EstacionCreateWithoutBicicletaInput
  }

  export type AlquilerCreateWithoutBicicletaInput = {
    fecha?: Date | string
    estado?: boolean
    Usuario: UsuarioCreateOneWithoutAlquilerInput
  }

  export type AlquilerCreateOrConnectWithoutBicicletaInput = {
    where: AlquilerWhereUniqueInput
    create: AlquilerCreateWithoutBicicletaInput
  }

  export type ReportarCreateWithoutBicicletaInput = {
    contenido?: string | null
    fecha?: Date | string
    estado?: boolean
    Usuario: UsuarioCreateOneWithoutReportarInput
  }

  export type ReportarCreateOrConnectWithoutBicicletaInput = {
    where: ReportarWhereUniqueInput
    create: ReportarCreateWithoutBicicletaInput
  }

  export type EstacionUpdateWithoutBicicletaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EstacionUpsertWithoutBicicletaInput = {
    update: EstacionUpdateWithoutBicicletaInput
    create: EstacionCreateWithoutBicicletaInput
  }

  export type AlquilerUpdateWithWhereUniqueWithoutBicicletaInput = {
    where: AlquilerWhereUniqueInput
    data: AlquilerUpdateWithoutBicicletaInput
  }

  export type AlquilerUpdateManyWithWhereWithoutBicicletaInput = {
    where: AlquilerScalarWhereInput
    data: AlquilerUpdateManyMutationInput
  }

  export type AlquilerUpsertWithWhereUniqueWithoutBicicletaInput = {
    where: AlquilerWhereUniqueInput
    update: AlquilerUpdateWithoutBicicletaInput
    create: AlquilerCreateWithoutBicicletaInput
  }

  export type ReportarUpdateWithWhereUniqueWithoutBicicletaInput = {
    where: ReportarWhereUniqueInput
    data: ReportarUpdateWithoutBicicletaInput
  }

  export type ReportarUpdateManyWithWhereWithoutBicicletaInput = {
    where: ReportarScalarWhereInput
    data: ReportarUpdateManyMutationInput
  }

  export type ReportarUpsertWithWhereUniqueWithoutBicicletaInput = {
    where: ReportarWhereUniqueInput
    update: ReportarUpdateWithoutBicicletaInput
    create: ReportarCreateWithoutBicicletaInput
  }

  export type BicicletaCreateWithoutAlquilerInput = {
    estado: string
    Estacion: EstacionCreateOneWithoutBicicletaInput
    Reportar?: ReportarCreateManyWithoutBicicletaInput
  }

  export type BicicletaCreateOrConnectWithoutAlquilerInput = {
    where: BicicletaWhereUniqueInput
    create: BicicletaCreateWithoutAlquilerInput
  }

  export type UsuarioCreateWithoutAlquilerInput = {
    usuario: string
    pass: string
    matricula: number
    Reportar?: ReportarCreateManyWithoutUsuarioInput
    Publicacion?: PublicacionCreateManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAlquilerInput = {
    where: UsuarioWhereUniqueInput
    create: UsuarioCreateWithoutAlquilerInput
  }

  export type BicicletaUpdateWithoutAlquilerInput = {
    estado?: StringFieldUpdateOperationsInput | string
    Estacion?: EstacionUpdateOneRequiredWithoutBicicletaInput
    Reportar?: ReportarUpdateManyWithoutBicicletaInput
  }

  export type BicicletaUpsertWithoutAlquilerInput = {
    update: BicicletaUpdateWithoutAlquilerInput
    create: BicicletaCreateWithoutAlquilerInput
  }

  export type UsuarioUpdateWithoutAlquilerInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    matricula?: IntFieldUpdateOperationsInput | number
    Reportar?: ReportarUpdateManyWithoutUsuarioInput
    Publicacion?: PublicacionUpdateManyWithoutUsuarioInput
  }

  export type UsuarioUpsertWithoutAlquilerInput = {
    update: UsuarioUpdateWithoutAlquilerInput
    create: UsuarioCreateWithoutAlquilerInput
  }

  export type BicicletaCreateWithoutReportarInput = {
    estado: string
    Estacion: EstacionCreateOneWithoutBicicletaInput
    Alquiler?: AlquilerCreateManyWithoutBicicletaInput
  }

  export type BicicletaCreateOrConnectWithoutReportarInput = {
    where: BicicletaWhereUniqueInput
    create: BicicletaCreateWithoutReportarInput
  }

  export type UsuarioCreateWithoutReportarInput = {
    usuario: string
    pass: string
    matricula: number
    Alquiler?: AlquilerCreateManyWithoutUsuarioInput
    Publicacion?: PublicacionCreateManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutReportarInput = {
    where: UsuarioWhereUniqueInput
    create: UsuarioCreateWithoutReportarInput
  }

  export type BicicletaUpdateWithoutReportarInput = {
    estado?: StringFieldUpdateOperationsInput | string
    Estacion?: EstacionUpdateOneRequiredWithoutBicicletaInput
    Alquiler?: AlquilerUpdateManyWithoutBicicletaInput
  }

  export type BicicletaUpsertWithoutReportarInput = {
    update: BicicletaUpdateWithoutReportarInput
    create: BicicletaCreateWithoutReportarInput
  }

  export type UsuarioUpdateWithoutReportarInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    matricula?: IntFieldUpdateOperationsInput | number
    Alquiler?: AlquilerUpdateManyWithoutUsuarioInput
    Publicacion?: PublicacionUpdateManyWithoutUsuarioInput
  }

  export type UsuarioUpsertWithoutReportarInput = {
    update: UsuarioUpdateWithoutReportarInput
    create: UsuarioCreateWithoutReportarInput
  }

  export type InformacionCreateWithoutForoInput = {
    titulo: string
    contenido?: string | null
  }

  export type InformacionCreateOrConnectWithoutForoInput = {
    where: InformacionWhereUniqueInput
    create: InformacionCreateWithoutForoInput
  }

  export type PublicacionCreateWithoutForoInput = {
    fecha?: Date | string
    contenido?: string | null
    Usuario: UsuarioCreateOneWithoutPublicacionInput
  }

  export type PublicacionCreateOrConnectWithoutForoInput = {
    where: PublicacionWhereUniqueInput
    create: PublicacionCreateWithoutForoInput
  }

  export type InformacionUpdateWithWhereUniqueWithoutForoInput = {
    where: InformacionWhereUniqueInput
    data: InformacionUpdateWithoutForoInput
  }

  export type InformacionUpdateManyWithWhereWithoutForoInput = {
    where: InformacionScalarWhereInput
    data: InformacionUpdateManyMutationInput
  }

  export type InformacionScalarWhereInput = {
    AND?: Enumerable<InformacionScalarWhereInput>
    OR?: Enumerable<InformacionScalarWhereInput>
    NOT?: Enumerable<InformacionScalarWhereInput>
    idInformacion?: IntFilter | number
    titulo?: StringFilter | string
    contenido?: StringNullableFilter | string | null
    foro?: IntFilter | number
  }

  export type InformacionUpsertWithWhereUniqueWithoutForoInput = {
    where: InformacionWhereUniqueInput
    update: InformacionUpdateWithoutForoInput
    create: InformacionCreateWithoutForoInput
  }

  export type PublicacionUpdateWithWhereUniqueWithoutForoInput = {
    where: PublicacionWhereUniqueInput
    data: PublicacionUpdateWithoutForoInput
  }

  export type PublicacionUpdateManyWithWhereWithoutForoInput = {
    where: PublicacionScalarWhereInput
    data: PublicacionUpdateManyMutationInput
  }

  export type PublicacionUpsertWithWhereUniqueWithoutForoInput = {
    where: PublicacionWhereUniqueInput
    update: PublicacionUpdateWithoutForoInput
    create: PublicacionCreateWithoutForoInput
  }

  export type ForoCreateWithoutInformacionInput = {
    descripcion?: string | null
    Publicacion?: PublicacionCreateManyWithoutForoInput
  }

  export type ForoCreateOrConnectWithoutInformacionInput = {
    where: ForoWhereUniqueInput
    create: ForoCreateWithoutInformacionInput
  }

  export type ForoUpdateWithoutInformacionInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Publicacion?: PublicacionUpdateManyWithoutForoInput
  }

  export type ForoUpsertWithoutInformacionInput = {
    update: ForoUpdateWithoutInformacionInput
    create: ForoCreateWithoutInformacionInput
  }

  export type ForoCreateWithoutPublicacionInput = {
    descripcion?: string | null
    Informacion?: InformacionCreateManyWithoutForoInput
  }

  export type ForoCreateOrConnectWithoutPublicacionInput = {
    where: ForoWhereUniqueInput
    create: ForoCreateWithoutPublicacionInput
  }

  export type UsuarioCreateWithoutPublicacionInput = {
    usuario: string
    pass: string
    matricula: number
    Alquiler?: AlquilerCreateManyWithoutUsuarioInput
    Reportar?: ReportarCreateManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPublicacionInput = {
    where: UsuarioWhereUniqueInput
    create: UsuarioCreateWithoutPublicacionInput
  }

  export type ForoUpdateWithoutPublicacionInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    Informacion?: InformacionUpdateManyWithoutForoInput
  }

  export type ForoUpsertWithoutPublicacionInput = {
    update: ForoUpdateWithoutPublicacionInput
    create: ForoCreateWithoutPublicacionInput
  }

  export type UsuarioUpdateWithoutPublicacionInput = {
    usuario?: StringFieldUpdateOperationsInput | string
    pass?: StringFieldUpdateOperationsInput | string
    matricula?: IntFieldUpdateOperationsInput | number
    Alquiler?: AlquilerUpdateManyWithoutUsuarioInput
    Reportar?: ReportarUpdateManyWithoutUsuarioInput
  }

  export type UsuarioUpsertWithoutPublicacionInput = {
    update: UsuarioUpdateWithoutPublicacionInput
    create: UsuarioCreateWithoutPublicacionInput
  }

  export type AlquilerUpdateWithoutUsuarioInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Bicicleta?: BicicletaUpdateOneRequiredWithoutAlquilerInput
  }

  export type ReportarUpdateWithoutUsuarioInput = {
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Bicicleta?: BicicletaUpdateOneRequiredWithoutReportarInput
  }

  export type PublicacionUpdateWithoutUsuarioInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
    Foro?: ForoUpdateOneRequiredWithoutPublicacionInput
  }

  export type BicicletaUpdateWithoutEstacionInput = {
    estado?: StringFieldUpdateOperationsInput | string
    Alquiler?: AlquilerUpdateManyWithoutBicicletaInput
    Reportar?: ReportarUpdateManyWithoutBicicletaInput
  }

  export type AlquilerUpdateWithoutBicicletaInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Usuario?: UsuarioUpdateOneRequiredWithoutAlquilerInput
  }

  export type ReportarUpdateWithoutBicicletaInput = {
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: BoolFieldUpdateOperationsInput | boolean
    Usuario?: UsuarioUpdateOneRequiredWithoutReportarInput
  }

  export type InformacionUpdateWithoutForoInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublicacionUpdateWithoutForoInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    contenido?: NullableStringFieldUpdateOperationsInput | string | null
    Usuario?: UsuarioUpdateOneRequiredWithoutPublicacionInput
  }



  /**
   * Batch Payload for updateMany & deleteMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}

/*
* Exports for compatibility introduced in 2.12.0
* Please import from the Prisma namespace instead
*/

/**
 * @deprecated Renamed to `Prisma.UsuarioScalarFieldEnum`
 */
export type UsuarioScalarFieldEnum = Prisma.UsuarioScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.EstacionScalarFieldEnum`
 */
export type EstacionScalarFieldEnum = Prisma.EstacionScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.BicicletaScalarFieldEnum`
 */
export type BicicletaScalarFieldEnum = Prisma.BicicletaScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.AlquilerScalarFieldEnum`
 */
export type AlquilerScalarFieldEnum = Prisma.AlquilerScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.ReportarScalarFieldEnum`
 */
export type ReportarScalarFieldEnum = Prisma.ReportarScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.ForoScalarFieldEnum`
 */
export type ForoScalarFieldEnum = Prisma.ForoScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.InformacionScalarFieldEnum`
 */
export type InformacionScalarFieldEnum = Prisma.InformacionScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.PublicacionScalarFieldEnum`
 */
export type PublicacionScalarFieldEnum = Prisma.PublicacionScalarFieldEnum

/**
 * @deprecated Renamed to `Prisma.SortOrder`
 */
export type SortOrder = Prisma.SortOrder

/**
 * @deprecated Renamed to `Prisma.ModelName`
 */
export type ModelName = Prisma.ModelName

/**
 * @deprecated Renamed to `Prisma.AggregateUsuario`
 */
export type AggregateUsuario = Prisma.AggregateUsuario

/**
 * @deprecated Renamed to `Prisma.UsuarioAvgAggregateOutputType`
 */
export type UsuarioAvgAggregateOutputType = Prisma.UsuarioAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UsuarioSumAggregateOutputType`
 */
export type UsuarioSumAggregateOutputType = Prisma.UsuarioSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UsuarioMinAggregateOutputType`
 */
export type UsuarioMinAggregateOutputType = Prisma.UsuarioMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UsuarioMaxAggregateOutputType`
 */
export type UsuarioMaxAggregateOutputType = Prisma.UsuarioMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.UsuarioCountAggregateOutputType`
 */
export type UsuarioCountAggregateOutputType = Prisma.UsuarioCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateUsuarioArgs`
 */
export type AggregateUsuarioArgs = Prisma.AggregateUsuarioArgs

/**
 * @deprecated Renamed to `Prisma.UsuarioAvgAggregateInputType`
 */
export type UsuarioAvgAggregateInputType = Prisma.UsuarioAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UsuarioSumAggregateInputType`
 */
export type UsuarioSumAggregateInputType = Prisma.UsuarioSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UsuarioMinAggregateInputType`
 */
export type UsuarioMinAggregateInputType = Prisma.UsuarioMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UsuarioMaxAggregateInputType`
 */
export type UsuarioMaxAggregateInputType = Prisma.UsuarioMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UsuarioCountAggregateInputType`
 */
export type UsuarioCountAggregateInputType = Prisma.UsuarioCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.UsuarioSelect`
 */
export type UsuarioSelect = Prisma.UsuarioSelect

/**
 * @deprecated Renamed to `Prisma.UsuarioInclude`
 */
export type UsuarioInclude = Prisma.UsuarioInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueUsuarioArgs`
 */
export type FindUniqueUsuarioArgs = Prisma.FindUniqueUsuarioArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstUsuarioArgs`
 */
export type FindFirstUsuarioArgs = Prisma.FindFirstUsuarioArgs

/**
 * @deprecated Renamed to `Prisma.FindManyUsuarioArgs`
 */
export type FindManyUsuarioArgs = Prisma.FindManyUsuarioArgs

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateArgs`
 */
export type UsuarioCreateArgs = Prisma.UsuarioCreateArgs

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateArgs`
 */
export type UsuarioUpdateArgs = Prisma.UsuarioUpdateArgs

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateManyArgs`
 */
export type UsuarioUpdateManyArgs = Prisma.UsuarioUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.UsuarioUpsertArgs`
 */
export type UsuarioUpsertArgs = Prisma.UsuarioUpsertArgs

/**
 * @deprecated Renamed to `Prisma.UsuarioDeleteArgs`
 */
export type UsuarioDeleteArgs = Prisma.UsuarioDeleteArgs

/**
 * @deprecated Renamed to `Prisma.UsuarioDeleteManyArgs`
 */
export type UsuarioDeleteManyArgs = Prisma.UsuarioDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateEstacion`
 */
export type AggregateEstacion = Prisma.AggregateEstacion

/**
 * @deprecated Renamed to `Prisma.EstacionAvgAggregateOutputType`
 */
export type EstacionAvgAggregateOutputType = Prisma.EstacionAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.EstacionSumAggregateOutputType`
 */
export type EstacionSumAggregateOutputType = Prisma.EstacionSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.EstacionMinAggregateOutputType`
 */
export type EstacionMinAggregateOutputType = Prisma.EstacionMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.EstacionMaxAggregateOutputType`
 */
export type EstacionMaxAggregateOutputType = Prisma.EstacionMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.EstacionCountAggregateOutputType`
 */
export type EstacionCountAggregateOutputType = Prisma.EstacionCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateEstacionArgs`
 */
export type AggregateEstacionArgs = Prisma.AggregateEstacionArgs

/**
 * @deprecated Renamed to `Prisma.EstacionAvgAggregateInputType`
 */
export type EstacionAvgAggregateInputType = Prisma.EstacionAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EstacionSumAggregateInputType`
 */
export type EstacionSumAggregateInputType = Prisma.EstacionSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EstacionMinAggregateInputType`
 */
export type EstacionMinAggregateInputType = Prisma.EstacionMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EstacionMaxAggregateInputType`
 */
export type EstacionMaxAggregateInputType = Prisma.EstacionMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EstacionCountAggregateInputType`
 */
export type EstacionCountAggregateInputType = Prisma.EstacionCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.EstacionSelect`
 */
export type EstacionSelect = Prisma.EstacionSelect

/**
 * @deprecated Renamed to `Prisma.EstacionInclude`
 */
export type EstacionInclude = Prisma.EstacionInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueEstacionArgs`
 */
export type FindUniqueEstacionArgs = Prisma.FindUniqueEstacionArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstEstacionArgs`
 */
export type FindFirstEstacionArgs = Prisma.FindFirstEstacionArgs

/**
 * @deprecated Renamed to `Prisma.FindManyEstacionArgs`
 */
export type FindManyEstacionArgs = Prisma.FindManyEstacionArgs

/**
 * @deprecated Renamed to `Prisma.EstacionCreateArgs`
 */
export type EstacionCreateArgs = Prisma.EstacionCreateArgs

/**
 * @deprecated Renamed to `Prisma.EstacionUpdateArgs`
 */
export type EstacionUpdateArgs = Prisma.EstacionUpdateArgs

/**
 * @deprecated Renamed to `Prisma.EstacionUpdateManyArgs`
 */
export type EstacionUpdateManyArgs = Prisma.EstacionUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.EstacionUpsertArgs`
 */
export type EstacionUpsertArgs = Prisma.EstacionUpsertArgs

/**
 * @deprecated Renamed to `Prisma.EstacionDeleteArgs`
 */
export type EstacionDeleteArgs = Prisma.EstacionDeleteArgs

/**
 * @deprecated Renamed to `Prisma.EstacionDeleteManyArgs`
 */
export type EstacionDeleteManyArgs = Prisma.EstacionDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateBicicleta`
 */
export type AggregateBicicleta = Prisma.AggregateBicicleta

/**
 * @deprecated Renamed to `Prisma.BicicletaAvgAggregateOutputType`
 */
export type BicicletaAvgAggregateOutputType = Prisma.BicicletaAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.BicicletaSumAggregateOutputType`
 */
export type BicicletaSumAggregateOutputType = Prisma.BicicletaSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.BicicletaMinAggregateOutputType`
 */
export type BicicletaMinAggregateOutputType = Prisma.BicicletaMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.BicicletaMaxAggregateOutputType`
 */
export type BicicletaMaxAggregateOutputType = Prisma.BicicletaMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.BicicletaCountAggregateOutputType`
 */
export type BicicletaCountAggregateOutputType = Prisma.BicicletaCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateBicicletaArgs`
 */
export type AggregateBicicletaArgs = Prisma.AggregateBicicletaArgs

/**
 * @deprecated Renamed to `Prisma.BicicletaAvgAggregateInputType`
 */
export type BicicletaAvgAggregateInputType = Prisma.BicicletaAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.BicicletaSumAggregateInputType`
 */
export type BicicletaSumAggregateInputType = Prisma.BicicletaSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.BicicletaMinAggregateInputType`
 */
export type BicicletaMinAggregateInputType = Prisma.BicicletaMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.BicicletaMaxAggregateInputType`
 */
export type BicicletaMaxAggregateInputType = Prisma.BicicletaMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.BicicletaCountAggregateInputType`
 */
export type BicicletaCountAggregateInputType = Prisma.BicicletaCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.BicicletaSelect`
 */
export type BicicletaSelect = Prisma.BicicletaSelect

/**
 * @deprecated Renamed to `Prisma.BicicletaInclude`
 */
export type BicicletaInclude = Prisma.BicicletaInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueBicicletaArgs`
 */
export type FindUniqueBicicletaArgs = Prisma.FindUniqueBicicletaArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstBicicletaArgs`
 */
export type FindFirstBicicletaArgs = Prisma.FindFirstBicicletaArgs

/**
 * @deprecated Renamed to `Prisma.FindManyBicicletaArgs`
 */
export type FindManyBicicletaArgs = Prisma.FindManyBicicletaArgs

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateArgs`
 */
export type BicicletaCreateArgs = Prisma.BicicletaCreateArgs

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateArgs`
 */
export type BicicletaUpdateArgs = Prisma.BicicletaUpdateArgs

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateManyArgs`
 */
export type BicicletaUpdateManyArgs = Prisma.BicicletaUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.BicicletaUpsertArgs`
 */
export type BicicletaUpsertArgs = Prisma.BicicletaUpsertArgs

/**
 * @deprecated Renamed to `Prisma.BicicletaDeleteArgs`
 */
export type BicicletaDeleteArgs = Prisma.BicicletaDeleteArgs

/**
 * @deprecated Renamed to `Prisma.BicicletaDeleteManyArgs`
 */
export type BicicletaDeleteManyArgs = Prisma.BicicletaDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateAlquiler`
 */
export type AggregateAlquiler = Prisma.AggregateAlquiler

/**
 * @deprecated Renamed to `Prisma.AlquilerAvgAggregateOutputType`
 */
export type AlquilerAvgAggregateOutputType = Prisma.AlquilerAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AlquilerSumAggregateOutputType`
 */
export type AlquilerSumAggregateOutputType = Prisma.AlquilerSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AlquilerMinAggregateOutputType`
 */
export type AlquilerMinAggregateOutputType = Prisma.AlquilerMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AlquilerMaxAggregateOutputType`
 */
export type AlquilerMaxAggregateOutputType = Prisma.AlquilerMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AlquilerCountAggregateOutputType`
 */
export type AlquilerCountAggregateOutputType = Prisma.AlquilerCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateAlquilerArgs`
 */
export type AggregateAlquilerArgs = Prisma.AggregateAlquilerArgs

/**
 * @deprecated Renamed to `Prisma.AlquilerAvgAggregateInputType`
 */
export type AlquilerAvgAggregateInputType = Prisma.AlquilerAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AlquilerSumAggregateInputType`
 */
export type AlquilerSumAggregateInputType = Prisma.AlquilerSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AlquilerMinAggregateInputType`
 */
export type AlquilerMinAggregateInputType = Prisma.AlquilerMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AlquilerMaxAggregateInputType`
 */
export type AlquilerMaxAggregateInputType = Prisma.AlquilerMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AlquilerCountAggregateInputType`
 */
export type AlquilerCountAggregateInputType = Prisma.AlquilerCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.AlquilerSelect`
 */
export type AlquilerSelect = Prisma.AlquilerSelect

/**
 * @deprecated Renamed to `Prisma.AlquilerInclude`
 */
export type AlquilerInclude = Prisma.AlquilerInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueAlquilerArgs`
 */
export type FindUniqueAlquilerArgs = Prisma.FindUniqueAlquilerArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstAlquilerArgs`
 */
export type FindFirstAlquilerArgs = Prisma.FindFirstAlquilerArgs

/**
 * @deprecated Renamed to `Prisma.FindManyAlquilerArgs`
 */
export type FindManyAlquilerArgs = Prisma.FindManyAlquilerArgs

/**
 * @deprecated Renamed to `Prisma.AlquilerCreateArgs`
 */
export type AlquilerCreateArgs = Prisma.AlquilerCreateArgs

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateArgs`
 */
export type AlquilerUpdateArgs = Prisma.AlquilerUpdateArgs

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateManyArgs`
 */
export type AlquilerUpdateManyArgs = Prisma.AlquilerUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.AlquilerUpsertArgs`
 */
export type AlquilerUpsertArgs = Prisma.AlquilerUpsertArgs

/**
 * @deprecated Renamed to `Prisma.AlquilerDeleteArgs`
 */
export type AlquilerDeleteArgs = Prisma.AlquilerDeleteArgs

/**
 * @deprecated Renamed to `Prisma.AlquilerDeleteManyArgs`
 */
export type AlquilerDeleteManyArgs = Prisma.AlquilerDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateReportar`
 */
export type AggregateReportar = Prisma.AggregateReportar

/**
 * @deprecated Renamed to `Prisma.ReportarAvgAggregateOutputType`
 */
export type ReportarAvgAggregateOutputType = Prisma.ReportarAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReportarSumAggregateOutputType`
 */
export type ReportarSumAggregateOutputType = Prisma.ReportarSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReportarMinAggregateOutputType`
 */
export type ReportarMinAggregateOutputType = Prisma.ReportarMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReportarMaxAggregateOutputType`
 */
export type ReportarMaxAggregateOutputType = Prisma.ReportarMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ReportarCountAggregateOutputType`
 */
export type ReportarCountAggregateOutputType = Prisma.ReportarCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateReportarArgs`
 */
export type AggregateReportarArgs = Prisma.AggregateReportarArgs

/**
 * @deprecated Renamed to `Prisma.ReportarAvgAggregateInputType`
 */
export type ReportarAvgAggregateInputType = Prisma.ReportarAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReportarSumAggregateInputType`
 */
export type ReportarSumAggregateInputType = Prisma.ReportarSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReportarMinAggregateInputType`
 */
export type ReportarMinAggregateInputType = Prisma.ReportarMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReportarMaxAggregateInputType`
 */
export type ReportarMaxAggregateInputType = Prisma.ReportarMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReportarCountAggregateInputType`
 */
export type ReportarCountAggregateInputType = Prisma.ReportarCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ReportarSelect`
 */
export type ReportarSelect = Prisma.ReportarSelect

/**
 * @deprecated Renamed to `Prisma.ReportarInclude`
 */
export type ReportarInclude = Prisma.ReportarInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueReportarArgs`
 */
export type FindUniqueReportarArgs = Prisma.FindUniqueReportarArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstReportarArgs`
 */
export type FindFirstReportarArgs = Prisma.FindFirstReportarArgs

/**
 * @deprecated Renamed to `Prisma.FindManyReportarArgs`
 */
export type FindManyReportarArgs = Prisma.FindManyReportarArgs

/**
 * @deprecated Renamed to `Prisma.ReportarCreateArgs`
 */
export type ReportarCreateArgs = Prisma.ReportarCreateArgs

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateArgs`
 */
export type ReportarUpdateArgs = Prisma.ReportarUpdateArgs

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateManyArgs`
 */
export type ReportarUpdateManyArgs = Prisma.ReportarUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.ReportarUpsertArgs`
 */
export type ReportarUpsertArgs = Prisma.ReportarUpsertArgs

/**
 * @deprecated Renamed to `Prisma.ReportarDeleteArgs`
 */
export type ReportarDeleteArgs = Prisma.ReportarDeleteArgs

/**
 * @deprecated Renamed to `Prisma.ReportarDeleteManyArgs`
 */
export type ReportarDeleteManyArgs = Prisma.ReportarDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateForo`
 */
export type AggregateForo = Prisma.AggregateForo

/**
 * @deprecated Renamed to `Prisma.ForoAvgAggregateOutputType`
 */
export type ForoAvgAggregateOutputType = Prisma.ForoAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ForoSumAggregateOutputType`
 */
export type ForoSumAggregateOutputType = Prisma.ForoSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ForoMinAggregateOutputType`
 */
export type ForoMinAggregateOutputType = Prisma.ForoMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ForoMaxAggregateOutputType`
 */
export type ForoMaxAggregateOutputType = Prisma.ForoMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.ForoCountAggregateOutputType`
 */
export type ForoCountAggregateOutputType = Prisma.ForoCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateForoArgs`
 */
export type AggregateForoArgs = Prisma.AggregateForoArgs

/**
 * @deprecated Renamed to `Prisma.ForoAvgAggregateInputType`
 */
export type ForoAvgAggregateInputType = Prisma.ForoAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ForoSumAggregateInputType`
 */
export type ForoSumAggregateInputType = Prisma.ForoSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ForoMinAggregateInputType`
 */
export type ForoMinAggregateInputType = Prisma.ForoMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ForoMaxAggregateInputType`
 */
export type ForoMaxAggregateInputType = Prisma.ForoMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ForoCountAggregateInputType`
 */
export type ForoCountAggregateInputType = Prisma.ForoCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.ForoSelect`
 */
export type ForoSelect = Prisma.ForoSelect

/**
 * @deprecated Renamed to `Prisma.ForoInclude`
 */
export type ForoInclude = Prisma.ForoInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueForoArgs`
 */
export type FindUniqueForoArgs = Prisma.FindUniqueForoArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstForoArgs`
 */
export type FindFirstForoArgs = Prisma.FindFirstForoArgs

/**
 * @deprecated Renamed to `Prisma.FindManyForoArgs`
 */
export type FindManyForoArgs = Prisma.FindManyForoArgs

/**
 * @deprecated Renamed to `Prisma.ForoCreateArgs`
 */
export type ForoCreateArgs = Prisma.ForoCreateArgs

/**
 * @deprecated Renamed to `Prisma.ForoUpdateArgs`
 */
export type ForoUpdateArgs = Prisma.ForoUpdateArgs

/**
 * @deprecated Renamed to `Prisma.ForoUpdateManyArgs`
 */
export type ForoUpdateManyArgs = Prisma.ForoUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.ForoUpsertArgs`
 */
export type ForoUpsertArgs = Prisma.ForoUpsertArgs

/**
 * @deprecated Renamed to `Prisma.ForoDeleteArgs`
 */
export type ForoDeleteArgs = Prisma.ForoDeleteArgs

/**
 * @deprecated Renamed to `Prisma.ForoDeleteManyArgs`
 */
export type ForoDeleteManyArgs = Prisma.ForoDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregateInformacion`
 */
export type AggregateInformacion = Prisma.AggregateInformacion

/**
 * @deprecated Renamed to `Prisma.InformacionAvgAggregateOutputType`
 */
export type InformacionAvgAggregateOutputType = Prisma.InformacionAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.InformacionSumAggregateOutputType`
 */
export type InformacionSumAggregateOutputType = Prisma.InformacionSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.InformacionMinAggregateOutputType`
 */
export type InformacionMinAggregateOutputType = Prisma.InformacionMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.InformacionMaxAggregateOutputType`
 */
export type InformacionMaxAggregateOutputType = Prisma.InformacionMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.InformacionCountAggregateOutputType`
 */
export type InformacionCountAggregateOutputType = Prisma.InformacionCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregateInformacionArgs`
 */
export type AggregateInformacionArgs = Prisma.AggregateInformacionArgs

/**
 * @deprecated Renamed to `Prisma.InformacionAvgAggregateInputType`
 */
export type InformacionAvgAggregateInputType = Prisma.InformacionAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InformacionSumAggregateInputType`
 */
export type InformacionSumAggregateInputType = Prisma.InformacionSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InformacionMinAggregateInputType`
 */
export type InformacionMinAggregateInputType = Prisma.InformacionMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InformacionMaxAggregateInputType`
 */
export type InformacionMaxAggregateInputType = Prisma.InformacionMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InformacionCountAggregateInputType`
 */
export type InformacionCountAggregateInputType = Prisma.InformacionCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.InformacionSelect`
 */
export type InformacionSelect = Prisma.InformacionSelect

/**
 * @deprecated Renamed to `Prisma.InformacionInclude`
 */
export type InformacionInclude = Prisma.InformacionInclude

/**
 * @deprecated Renamed to `Prisma.FindUniqueInformacionArgs`
 */
export type FindUniqueInformacionArgs = Prisma.FindUniqueInformacionArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstInformacionArgs`
 */
export type FindFirstInformacionArgs = Prisma.FindFirstInformacionArgs

/**
 * @deprecated Renamed to `Prisma.FindManyInformacionArgs`
 */
export type FindManyInformacionArgs = Prisma.FindManyInformacionArgs

/**
 * @deprecated Renamed to `Prisma.InformacionCreateArgs`
 */
export type InformacionCreateArgs = Prisma.InformacionCreateArgs

/**
 * @deprecated Renamed to `Prisma.InformacionUpdateArgs`
 */
export type InformacionUpdateArgs = Prisma.InformacionUpdateArgs

/**
 * @deprecated Renamed to `Prisma.InformacionUpdateManyArgs`
 */
export type InformacionUpdateManyArgs = Prisma.InformacionUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.InformacionUpsertArgs`
 */
export type InformacionUpsertArgs = Prisma.InformacionUpsertArgs

/**
 * @deprecated Renamed to `Prisma.InformacionDeleteArgs`
 */
export type InformacionDeleteArgs = Prisma.InformacionDeleteArgs

/**
 * @deprecated Renamed to `Prisma.InformacionDeleteManyArgs`
 */
export type InformacionDeleteManyArgs = Prisma.InformacionDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.AggregatePublicacion`
 */
export type AggregatePublicacion = Prisma.AggregatePublicacion

/**
 * @deprecated Renamed to `Prisma.PublicacionAvgAggregateOutputType`
 */
export type PublicacionAvgAggregateOutputType = Prisma.PublicacionAvgAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PublicacionSumAggregateOutputType`
 */
export type PublicacionSumAggregateOutputType = Prisma.PublicacionSumAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PublicacionMinAggregateOutputType`
 */
export type PublicacionMinAggregateOutputType = Prisma.PublicacionMinAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PublicacionMaxAggregateOutputType`
 */
export type PublicacionMaxAggregateOutputType = Prisma.PublicacionMaxAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.PublicacionCountAggregateOutputType`
 */
export type PublicacionCountAggregateOutputType = Prisma.PublicacionCountAggregateOutputType

/**
 * @deprecated Renamed to `Prisma.AggregatePublicacionArgs`
 */
export type AggregatePublicacionArgs = Prisma.AggregatePublicacionArgs

/**
 * @deprecated Renamed to `Prisma.PublicacionAvgAggregateInputType`
 */
export type PublicacionAvgAggregateInputType = Prisma.PublicacionAvgAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PublicacionSumAggregateInputType`
 */
export type PublicacionSumAggregateInputType = Prisma.PublicacionSumAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PublicacionMinAggregateInputType`
 */
export type PublicacionMinAggregateInputType = Prisma.PublicacionMinAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PublicacionMaxAggregateInputType`
 */
export type PublicacionMaxAggregateInputType = Prisma.PublicacionMaxAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PublicacionCountAggregateInputType`
 */
export type PublicacionCountAggregateInputType = Prisma.PublicacionCountAggregateInputType

/**
 * @deprecated Renamed to `Prisma.PublicacionSelect`
 */
export type PublicacionSelect = Prisma.PublicacionSelect

/**
 * @deprecated Renamed to `Prisma.PublicacionInclude`
 */
export type PublicacionInclude = Prisma.PublicacionInclude

/**
 * @deprecated Renamed to `Prisma.FindUniquePublicacionArgs`
 */
export type FindUniquePublicacionArgs = Prisma.FindUniquePublicacionArgs

/**
 * @deprecated Renamed to `Prisma.FindFirstPublicacionArgs`
 */
export type FindFirstPublicacionArgs = Prisma.FindFirstPublicacionArgs

/**
 * @deprecated Renamed to `Prisma.FindManyPublicacionArgs`
 */
export type FindManyPublicacionArgs = Prisma.FindManyPublicacionArgs

/**
 * @deprecated Renamed to `Prisma.PublicacionCreateArgs`
 */
export type PublicacionCreateArgs = Prisma.PublicacionCreateArgs

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateArgs`
 */
export type PublicacionUpdateArgs = Prisma.PublicacionUpdateArgs

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateManyArgs`
 */
export type PublicacionUpdateManyArgs = Prisma.PublicacionUpdateManyArgs

/**
 * @deprecated Renamed to `Prisma.PublicacionUpsertArgs`
 */
export type PublicacionUpsertArgs = Prisma.PublicacionUpsertArgs

/**
 * @deprecated Renamed to `Prisma.PublicacionDeleteArgs`
 */
export type PublicacionDeleteArgs = Prisma.PublicacionDeleteArgs

/**
 * @deprecated Renamed to `Prisma.PublicacionDeleteManyArgs`
 */
export type PublicacionDeleteManyArgs = Prisma.PublicacionDeleteManyArgs

/**
 * @deprecated Renamed to `Prisma.UsuarioWhereInput`
 */
export type UsuarioWhereInput = Prisma.UsuarioWhereInput

/**
 * @deprecated Renamed to `Prisma.UsuarioOrderByInput`
 */
export type UsuarioOrderByInput = Prisma.UsuarioOrderByInput

/**
 * @deprecated Renamed to `Prisma.UsuarioWhereUniqueInput`
 */
export type UsuarioWhereUniqueInput = Prisma.UsuarioWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.EstacionWhereInput`
 */
export type EstacionWhereInput = Prisma.EstacionWhereInput

/**
 * @deprecated Renamed to `Prisma.EstacionOrderByInput`
 */
export type EstacionOrderByInput = Prisma.EstacionOrderByInput

/**
 * @deprecated Renamed to `Prisma.EstacionWhereUniqueInput`
 */
export type EstacionWhereUniqueInput = Prisma.EstacionWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.BicicletaWhereInput`
 */
export type BicicletaWhereInput = Prisma.BicicletaWhereInput

/**
 * @deprecated Renamed to `Prisma.BicicletaOrderByInput`
 */
export type BicicletaOrderByInput = Prisma.BicicletaOrderByInput

/**
 * @deprecated Renamed to `Prisma.BicicletaWhereUniqueInput`
 */
export type BicicletaWhereUniqueInput = Prisma.BicicletaWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.AlquilerWhereInput`
 */
export type AlquilerWhereInput = Prisma.AlquilerWhereInput

/**
 * @deprecated Renamed to `Prisma.AlquilerOrderByInput`
 */
export type AlquilerOrderByInput = Prisma.AlquilerOrderByInput

/**
 * @deprecated Renamed to `Prisma.AlquilerWhereUniqueInput`
 */
export type AlquilerWhereUniqueInput = Prisma.AlquilerWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.ReportarWhereInput`
 */
export type ReportarWhereInput = Prisma.ReportarWhereInput

/**
 * @deprecated Renamed to `Prisma.ReportarOrderByInput`
 */
export type ReportarOrderByInput = Prisma.ReportarOrderByInput

/**
 * @deprecated Renamed to `Prisma.ReportarWhereUniqueInput`
 */
export type ReportarWhereUniqueInput = Prisma.ReportarWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.ForoWhereInput`
 */
export type ForoWhereInput = Prisma.ForoWhereInput

/**
 * @deprecated Renamed to `Prisma.ForoOrderByInput`
 */
export type ForoOrderByInput = Prisma.ForoOrderByInput

/**
 * @deprecated Renamed to `Prisma.ForoWhereUniqueInput`
 */
export type ForoWhereUniqueInput = Prisma.ForoWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.InformacionWhereInput`
 */
export type InformacionWhereInput = Prisma.InformacionWhereInput

/**
 * @deprecated Renamed to `Prisma.InformacionOrderByInput`
 */
export type InformacionOrderByInput = Prisma.InformacionOrderByInput

/**
 * @deprecated Renamed to `Prisma.InformacionWhereUniqueInput`
 */
export type InformacionWhereUniqueInput = Prisma.InformacionWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.PublicacionWhereInput`
 */
export type PublicacionWhereInput = Prisma.PublicacionWhereInput

/**
 * @deprecated Renamed to `Prisma.PublicacionOrderByInput`
 */
export type PublicacionOrderByInput = Prisma.PublicacionOrderByInput

/**
 * @deprecated Renamed to `Prisma.PublicacionWhereUniqueInput`
 */
export type PublicacionWhereUniqueInput = Prisma.PublicacionWhereUniqueInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateInput`
 */
export type UsuarioCreateInput = Prisma.UsuarioCreateInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateInput`
 */
export type UsuarioUpdateInput = Prisma.UsuarioUpdateInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateManyMutationInput`
 */
export type UsuarioUpdateManyMutationInput = Prisma.UsuarioUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.EstacionCreateInput`
 */
export type EstacionCreateInput = Prisma.EstacionCreateInput

/**
 * @deprecated Renamed to `Prisma.EstacionUpdateInput`
 */
export type EstacionUpdateInput = Prisma.EstacionUpdateInput

/**
 * @deprecated Renamed to `Prisma.EstacionUpdateManyMutationInput`
 */
export type EstacionUpdateManyMutationInput = Prisma.EstacionUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateInput`
 */
export type BicicletaCreateInput = Prisma.BicicletaCreateInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateInput`
 */
export type BicicletaUpdateInput = Prisma.BicicletaUpdateInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateManyMutationInput`
 */
export type BicicletaUpdateManyMutationInput = Prisma.BicicletaUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.AlquilerCreateInput`
 */
export type AlquilerCreateInput = Prisma.AlquilerCreateInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateInput`
 */
export type AlquilerUpdateInput = Prisma.AlquilerUpdateInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateManyMutationInput`
 */
export type AlquilerUpdateManyMutationInput = Prisma.AlquilerUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.ReportarCreateInput`
 */
export type ReportarCreateInput = Prisma.ReportarCreateInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateInput`
 */
export type ReportarUpdateInput = Prisma.ReportarUpdateInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateManyMutationInput`
 */
export type ReportarUpdateManyMutationInput = Prisma.ReportarUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.ForoCreateInput`
 */
export type ForoCreateInput = Prisma.ForoCreateInput

/**
 * @deprecated Renamed to `Prisma.ForoUpdateInput`
 */
export type ForoUpdateInput = Prisma.ForoUpdateInput

/**
 * @deprecated Renamed to `Prisma.ForoUpdateManyMutationInput`
 */
export type ForoUpdateManyMutationInput = Prisma.ForoUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.InformacionCreateInput`
 */
export type InformacionCreateInput = Prisma.InformacionCreateInput

/**
 * @deprecated Renamed to `Prisma.InformacionUpdateInput`
 */
export type InformacionUpdateInput = Prisma.InformacionUpdateInput

/**
 * @deprecated Renamed to `Prisma.InformacionUpdateManyMutationInput`
 */
export type InformacionUpdateManyMutationInput = Prisma.InformacionUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.PublicacionCreateInput`
 */
export type PublicacionCreateInput = Prisma.PublicacionCreateInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateInput`
 */
export type PublicacionUpdateInput = Prisma.PublicacionUpdateInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateManyMutationInput`
 */
export type PublicacionUpdateManyMutationInput = Prisma.PublicacionUpdateManyMutationInput

/**
 * @deprecated Renamed to `Prisma.IntFilter`
 */
export type IntFilter = Prisma.IntFilter

/**
 * @deprecated Renamed to `Prisma.StringFilter`
 */
export type StringFilter = Prisma.StringFilter

/**
 * @deprecated Renamed to `Prisma.AlquilerListRelationFilter`
 */
export type AlquilerListRelationFilter = Prisma.AlquilerListRelationFilter

/**
 * @deprecated Renamed to `Prisma.ReportarListRelationFilter`
 */
export type ReportarListRelationFilter = Prisma.ReportarListRelationFilter

/**
 * @deprecated Renamed to `Prisma.PublicacionListRelationFilter`
 */
export type PublicacionListRelationFilter = Prisma.PublicacionListRelationFilter

/**
 * @deprecated Renamed to `Prisma.BicicletaListRelationFilter`
 */
export type BicicletaListRelationFilter = Prisma.BicicletaListRelationFilter

/**
 * @deprecated Renamed to `Prisma.EstacionRelationFilter`
 */
export type EstacionRelationFilter = Prisma.EstacionRelationFilter

/**
 * @deprecated Renamed to `Prisma.DateTimeFilter`
 */
export type DateTimeFilter = Prisma.DateTimeFilter

/**
 * @deprecated Renamed to `Prisma.BicicletaRelationFilter`
 */
export type BicicletaRelationFilter = Prisma.BicicletaRelationFilter

/**
 * @deprecated Renamed to `Prisma.UsuarioRelationFilter`
 */
export type UsuarioRelationFilter = Prisma.UsuarioRelationFilter

/**
 * @deprecated Renamed to `Prisma.BoolFilter`
 */
export type BoolFilter = Prisma.BoolFilter

/**
 * @deprecated Renamed to `Prisma.StringNullableFilter`
 */
export type StringNullableFilter = Prisma.StringNullableFilter

/**
 * @deprecated Renamed to `Prisma.InformacionListRelationFilter`
 */
export type InformacionListRelationFilter = Prisma.InformacionListRelationFilter

/**
 * @deprecated Renamed to `Prisma.ForoRelationFilter`
 */
export type ForoRelationFilter = Prisma.ForoRelationFilter

/**
 * @deprecated Renamed to `Prisma.AlquilerCreateManyWithoutUsuarioInput`
 */
export type AlquilerCreateManyWithoutUsuarioInput = Prisma.AlquilerCreateManyWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.ReportarCreateManyWithoutUsuarioInput`
 */
export type ReportarCreateManyWithoutUsuarioInput = Prisma.ReportarCreateManyWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.PublicacionCreateManyWithoutUsuarioInput`
 */
export type PublicacionCreateManyWithoutUsuarioInput = Prisma.PublicacionCreateManyWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.StringFieldUpdateOperationsInput`
 */
export type StringFieldUpdateOperationsInput = Prisma.StringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.IntFieldUpdateOperationsInput`
 */
export type IntFieldUpdateOperationsInput = Prisma.IntFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateManyWithoutUsuarioInput`
 */
export type AlquilerUpdateManyWithoutUsuarioInput = Prisma.AlquilerUpdateManyWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateManyWithoutUsuarioInput`
 */
export type ReportarUpdateManyWithoutUsuarioInput = Prisma.ReportarUpdateManyWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateManyWithoutUsuarioInput`
 */
export type PublicacionUpdateManyWithoutUsuarioInput = Prisma.PublicacionUpdateManyWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateManyWithoutEstacionInput`
 */
export type BicicletaCreateManyWithoutEstacionInput = Prisma.BicicletaCreateManyWithoutEstacionInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateManyWithoutEstacionInput`
 */
export type BicicletaUpdateManyWithoutEstacionInput = Prisma.BicicletaUpdateManyWithoutEstacionInput

/**
 * @deprecated Renamed to `Prisma.EstacionCreateOneWithoutBicicletaInput`
 */
export type EstacionCreateOneWithoutBicicletaInput = Prisma.EstacionCreateOneWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.AlquilerCreateManyWithoutBicicletaInput`
 */
export type AlquilerCreateManyWithoutBicicletaInput = Prisma.AlquilerCreateManyWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.ReportarCreateManyWithoutBicicletaInput`
 */
export type ReportarCreateManyWithoutBicicletaInput = Prisma.ReportarCreateManyWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.EstacionUpdateOneRequiredWithoutBicicletaInput`
 */
export type EstacionUpdateOneRequiredWithoutBicicletaInput = Prisma.EstacionUpdateOneRequiredWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateManyWithoutBicicletaInput`
 */
export type AlquilerUpdateManyWithoutBicicletaInput = Prisma.AlquilerUpdateManyWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateManyWithoutBicicletaInput`
 */
export type ReportarUpdateManyWithoutBicicletaInput = Prisma.ReportarUpdateManyWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateOneWithoutAlquilerInput`
 */
export type BicicletaCreateOneWithoutAlquilerInput = Prisma.BicicletaCreateOneWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateOneWithoutAlquilerInput`
 */
export type UsuarioCreateOneWithoutAlquilerInput = Prisma.UsuarioCreateOneWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.DateTimeFieldUpdateOperationsInput`
 */
export type DateTimeFieldUpdateOperationsInput = Prisma.DateTimeFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.BoolFieldUpdateOperationsInput`
 */
export type BoolFieldUpdateOperationsInput = Prisma.BoolFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateOneRequiredWithoutAlquilerInput`
 */
export type BicicletaUpdateOneRequiredWithoutAlquilerInput = Prisma.BicicletaUpdateOneRequiredWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateOneRequiredWithoutAlquilerInput`
 */
export type UsuarioUpdateOneRequiredWithoutAlquilerInput = Prisma.UsuarioUpdateOneRequiredWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateOneWithoutReportarInput`
 */
export type BicicletaCreateOneWithoutReportarInput = Prisma.BicicletaCreateOneWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateOneWithoutReportarInput`
 */
export type UsuarioCreateOneWithoutReportarInput = Prisma.UsuarioCreateOneWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.NullableStringFieldUpdateOperationsInput`
 */
export type NullableStringFieldUpdateOperationsInput = Prisma.NullableStringFieldUpdateOperationsInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateOneRequiredWithoutReportarInput`
 */
export type BicicletaUpdateOneRequiredWithoutReportarInput = Prisma.BicicletaUpdateOneRequiredWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateOneRequiredWithoutReportarInput`
 */
export type UsuarioUpdateOneRequiredWithoutReportarInput = Prisma.UsuarioUpdateOneRequiredWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.InformacionCreateManyWithoutForoInput`
 */
export type InformacionCreateManyWithoutForoInput = Prisma.InformacionCreateManyWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.PublicacionCreateManyWithoutForoInput`
 */
export type PublicacionCreateManyWithoutForoInput = Prisma.PublicacionCreateManyWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.InformacionUpdateManyWithoutForoInput`
 */
export type InformacionUpdateManyWithoutForoInput = Prisma.InformacionUpdateManyWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateManyWithoutForoInput`
 */
export type PublicacionUpdateManyWithoutForoInput = Prisma.PublicacionUpdateManyWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.ForoCreateOneWithoutInformacionInput`
 */
export type ForoCreateOneWithoutInformacionInput = Prisma.ForoCreateOneWithoutInformacionInput

/**
 * @deprecated Renamed to `Prisma.ForoUpdateOneRequiredWithoutInformacionInput`
 */
export type ForoUpdateOneRequiredWithoutInformacionInput = Prisma.ForoUpdateOneRequiredWithoutInformacionInput

/**
 * @deprecated Renamed to `Prisma.ForoCreateOneWithoutPublicacionInput`
 */
export type ForoCreateOneWithoutPublicacionInput = Prisma.ForoCreateOneWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateOneWithoutPublicacionInput`
 */
export type UsuarioCreateOneWithoutPublicacionInput = Prisma.UsuarioCreateOneWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.ForoUpdateOneRequiredWithoutPublicacionInput`
 */
export type ForoUpdateOneRequiredWithoutPublicacionInput = Prisma.ForoUpdateOneRequiredWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateOneRequiredWithoutPublicacionInput`
 */
export type UsuarioUpdateOneRequiredWithoutPublicacionInput = Prisma.UsuarioUpdateOneRequiredWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.NestedIntFilter`
 */
export type NestedIntFilter = Prisma.NestedIntFilter

/**
 * @deprecated Renamed to `Prisma.NestedStringFilter`
 */
export type NestedStringFilter = Prisma.NestedStringFilter

/**
 * @deprecated Renamed to `Prisma.NestedDateTimeFilter`
 */
export type NestedDateTimeFilter = Prisma.NestedDateTimeFilter

/**
 * @deprecated Renamed to `Prisma.NestedBoolFilter`
 */
export type NestedBoolFilter = Prisma.NestedBoolFilter

/**
 * @deprecated Renamed to `Prisma.NestedStringNullableFilter`
 */
export type NestedStringNullableFilter = Prisma.NestedStringNullableFilter

/**
 * @deprecated Renamed to `Prisma.AlquilerCreateWithoutUsuarioInput`
 */
export type AlquilerCreateWithoutUsuarioInput = Prisma.AlquilerCreateWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.AlquilerCreateOrConnectWithoutUsuarioInput`
 */
export type AlquilerCreateOrConnectWithoutUsuarioInput = Prisma.AlquilerCreateOrConnectWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.ReportarCreateWithoutUsuarioInput`
 */
export type ReportarCreateWithoutUsuarioInput = Prisma.ReportarCreateWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.ReportarCreateOrConnectWithoutUsuarioInput`
 */
export type ReportarCreateOrConnectWithoutUsuarioInput = Prisma.ReportarCreateOrConnectWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.PublicacionCreateWithoutUsuarioInput`
 */
export type PublicacionCreateWithoutUsuarioInput = Prisma.PublicacionCreateWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.PublicacionCreateOrConnectWithoutUsuarioInput`
 */
export type PublicacionCreateOrConnectWithoutUsuarioInput = Prisma.PublicacionCreateOrConnectWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateWithWhereUniqueWithoutUsuarioInput`
 */
export type AlquilerUpdateWithWhereUniqueWithoutUsuarioInput = Prisma.AlquilerUpdateWithWhereUniqueWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateManyWithWhereWithoutUsuarioInput`
 */
export type AlquilerUpdateManyWithWhereWithoutUsuarioInput = Prisma.AlquilerUpdateManyWithWhereWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.AlquilerScalarWhereInput`
 */
export type AlquilerScalarWhereInput = Prisma.AlquilerScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpsertWithWhereUniqueWithoutUsuarioInput`
 */
export type AlquilerUpsertWithWhereUniqueWithoutUsuarioInput = Prisma.AlquilerUpsertWithWhereUniqueWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateWithWhereUniqueWithoutUsuarioInput`
 */
export type ReportarUpdateWithWhereUniqueWithoutUsuarioInput = Prisma.ReportarUpdateWithWhereUniqueWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateManyWithWhereWithoutUsuarioInput`
 */
export type ReportarUpdateManyWithWhereWithoutUsuarioInput = Prisma.ReportarUpdateManyWithWhereWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.ReportarScalarWhereInput`
 */
export type ReportarScalarWhereInput = Prisma.ReportarScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpsertWithWhereUniqueWithoutUsuarioInput`
 */
export type ReportarUpsertWithWhereUniqueWithoutUsuarioInput = Prisma.ReportarUpsertWithWhereUniqueWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateWithWhereUniqueWithoutUsuarioInput`
 */
export type PublicacionUpdateWithWhereUniqueWithoutUsuarioInput = Prisma.PublicacionUpdateWithWhereUniqueWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateManyWithWhereWithoutUsuarioInput`
 */
export type PublicacionUpdateManyWithWhereWithoutUsuarioInput = Prisma.PublicacionUpdateManyWithWhereWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.PublicacionScalarWhereInput`
 */
export type PublicacionScalarWhereInput = Prisma.PublicacionScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpsertWithWhereUniqueWithoutUsuarioInput`
 */
export type PublicacionUpsertWithWhereUniqueWithoutUsuarioInput = Prisma.PublicacionUpsertWithWhereUniqueWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateWithoutEstacionInput`
 */
export type BicicletaCreateWithoutEstacionInput = Prisma.BicicletaCreateWithoutEstacionInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateOrConnectWithoutEstacionInput`
 */
export type BicicletaCreateOrConnectWithoutEstacionInput = Prisma.BicicletaCreateOrConnectWithoutEstacionInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateWithWhereUniqueWithoutEstacionInput`
 */
export type BicicletaUpdateWithWhereUniqueWithoutEstacionInput = Prisma.BicicletaUpdateWithWhereUniqueWithoutEstacionInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateManyWithWhereWithoutEstacionInput`
 */
export type BicicletaUpdateManyWithWhereWithoutEstacionInput = Prisma.BicicletaUpdateManyWithWhereWithoutEstacionInput

/**
 * @deprecated Renamed to `Prisma.BicicletaScalarWhereInput`
 */
export type BicicletaScalarWhereInput = Prisma.BicicletaScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpsertWithWhereUniqueWithoutEstacionInput`
 */
export type BicicletaUpsertWithWhereUniqueWithoutEstacionInput = Prisma.BicicletaUpsertWithWhereUniqueWithoutEstacionInput

/**
 * @deprecated Renamed to `Prisma.EstacionCreateWithoutBicicletaInput`
 */
export type EstacionCreateWithoutBicicletaInput = Prisma.EstacionCreateWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.EstacionCreateOrConnectWithoutBicicletaInput`
 */
export type EstacionCreateOrConnectWithoutBicicletaInput = Prisma.EstacionCreateOrConnectWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.AlquilerCreateWithoutBicicletaInput`
 */
export type AlquilerCreateWithoutBicicletaInput = Prisma.AlquilerCreateWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.AlquilerCreateOrConnectWithoutBicicletaInput`
 */
export type AlquilerCreateOrConnectWithoutBicicletaInput = Prisma.AlquilerCreateOrConnectWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.ReportarCreateWithoutBicicletaInput`
 */
export type ReportarCreateWithoutBicicletaInput = Prisma.ReportarCreateWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.ReportarCreateOrConnectWithoutBicicletaInput`
 */
export type ReportarCreateOrConnectWithoutBicicletaInput = Prisma.ReportarCreateOrConnectWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.EstacionUpdateWithoutBicicletaInput`
 */
export type EstacionUpdateWithoutBicicletaInput = Prisma.EstacionUpdateWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.EstacionUpsertWithoutBicicletaInput`
 */
export type EstacionUpsertWithoutBicicletaInput = Prisma.EstacionUpsertWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateWithWhereUniqueWithoutBicicletaInput`
 */
export type AlquilerUpdateWithWhereUniqueWithoutBicicletaInput = Prisma.AlquilerUpdateWithWhereUniqueWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateManyWithWhereWithoutBicicletaInput`
 */
export type AlquilerUpdateManyWithWhereWithoutBicicletaInput = Prisma.AlquilerUpdateManyWithWhereWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpsertWithWhereUniqueWithoutBicicletaInput`
 */
export type AlquilerUpsertWithWhereUniqueWithoutBicicletaInput = Prisma.AlquilerUpsertWithWhereUniqueWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateWithWhereUniqueWithoutBicicletaInput`
 */
export type ReportarUpdateWithWhereUniqueWithoutBicicletaInput = Prisma.ReportarUpdateWithWhereUniqueWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateManyWithWhereWithoutBicicletaInput`
 */
export type ReportarUpdateManyWithWhereWithoutBicicletaInput = Prisma.ReportarUpdateManyWithWhereWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpsertWithWhereUniqueWithoutBicicletaInput`
 */
export type ReportarUpsertWithWhereUniqueWithoutBicicletaInput = Prisma.ReportarUpsertWithWhereUniqueWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateWithoutAlquilerInput`
 */
export type BicicletaCreateWithoutAlquilerInput = Prisma.BicicletaCreateWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateOrConnectWithoutAlquilerInput`
 */
export type BicicletaCreateOrConnectWithoutAlquilerInput = Prisma.BicicletaCreateOrConnectWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateWithoutAlquilerInput`
 */
export type UsuarioCreateWithoutAlquilerInput = Prisma.UsuarioCreateWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateOrConnectWithoutAlquilerInput`
 */
export type UsuarioCreateOrConnectWithoutAlquilerInput = Prisma.UsuarioCreateOrConnectWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateWithoutAlquilerInput`
 */
export type BicicletaUpdateWithoutAlquilerInput = Prisma.BicicletaUpdateWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpsertWithoutAlquilerInput`
 */
export type BicicletaUpsertWithoutAlquilerInput = Prisma.BicicletaUpsertWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateWithoutAlquilerInput`
 */
export type UsuarioUpdateWithoutAlquilerInput = Prisma.UsuarioUpdateWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpsertWithoutAlquilerInput`
 */
export type UsuarioUpsertWithoutAlquilerInput = Prisma.UsuarioUpsertWithoutAlquilerInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateWithoutReportarInput`
 */
export type BicicletaCreateWithoutReportarInput = Prisma.BicicletaCreateWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.BicicletaCreateOrConnectWithoutReportarInput`
 */
export type BicicletaCreateOrConnectWithoutReportarInput = Prisma.BicicletaCreateOrConnectWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateWithoutReportarInput`
 */
export type UsuarioCreateWithoutReportarInput = Prisma.UsuarioCreateWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateOrConnectWithoutReportarInput`
 */
export type UsuarioCreateOrConnectWithoutReportarInput = Prisma.UsuarioCreateOrConnectWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateWithoutReportarInput`
 */
export type BicicletaUpdateWithoutReportarInput = Prisma.BicicletaUpdateWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpsertWithoutReportarInput`
 */
export type BicicletaUpsertWithoutReportarInput = Prisma.BicicletaUpsertWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateWithoutReportarInput`
 */
export type UsuarioUpdateWithoutReportarInput = Prisma.UsuarioUpdateWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpsertWithoutReportarInput`
 */
export type UsuarioUpsertWithoutReportarInput = Prisma.UsuarioUpsertWithoutReportarInput

/**
 * @deprecated Renamed to `Prisma.InformacionCreateWithoutForoInput`
 */
export type InformacionCreateWithoutForoInput = Prisma.InformacionCreateWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.InformacionCreateOrConnectWithoutForoInput`
 */
export type InformacionCreateOrConnectWithoutForoInput = Prisma.InformacionCreateOrConnectWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.PublicacionCreateWithoutForoInput`
 */
export type PublicacionCreateWithoutForoInput = Prisma.PublicacionCreateWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.PublicacionCreateOrConnectWithoutForoInput`
 */
export type PublicacionCreateOrConnectWithoutForoInput = Prisma.PublicacionCreateOrConnectWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.InformacionUpdateWithWhereUniqueWithoutForoInput`
 */
export type InformacionUpdateWithWhereUniqueWithoutForoInput = Prisma.InformacionUpdateWithWhereUniqueWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.InformacionUpdateManyWithWhereWithoutForoInput`
 */
export type InformacionUpdateManyWithWhereWithoutForoInput = Prisma.InformacionUpdateManyWithWhereWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.InformacionScalarWhereInput`
 */
export type InformacionScalarWhereInput = Prisma.InformacionScalarWhereInput

/**
 * @deprecated Renamed to `Prisma.InformacionUpsertWithWhereUniqueWithoutForoInput`
 */
export type InformacionUpsertWithWhereUniqueWithoutForoInput = Prisma.InformacionUpsertWithWhereUniqueWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateWithWhereUniqueWithoutForoInput`
 */
export type PublicacionUpdateWithWhereUniqueWithoutForoInput = Prisma.PublicacionUpdateWithWhereUniqueWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateManyWithWhereWithoutForoInput`
 */
export type PublicacionUpdateManyWithWhereWithoutForoInput = Prisma.PublicacionUpdateManyWithWhereWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpsertWithWhereUniqueWithoutForoInput`
 */
export type PublicacionUpsertWithWhereUniqueWithoutForoInput = Prisma.PublicacionUpsertWithWhereUniqueWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.ForoCreateWithoutInformacionInput`
 */
export type ForoCreateWithoutInformacionInput = Prisma.ForoCreateWithoutInformacionInput

/**
 * @deprecated Renamed to `Prisma.ForoCreateOrConnectWithoutInformacionInput`
 */
export type ForoCreateOrConnectWithoutInformacionInput = Prisma.ForoCreateOrConnectWithoutInformacionInput

/**
 * @deprecated Renamed to `Prisma.ForoUpdateWithoutInformacionInput`
 */
export type ForoUpdateWithoutInformacionInput = Prisma.ForoUpdateWithoutInformacionInput

/**
 * @deprecated Renamed to `Prisma.ForoUpsertWithoutInformacionInput`
 */
export type ForoUpsertWithoutInformacionInput = Prisma.ForoUpsertWithoutInformacionInput

/**
 * @deprecated Renamed to `Prisma.ForoCreateWithoutPublicacionInput`
 */
export type ForoCreateWithoutPublicacionInput = Prisma.ForoCreateWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.ForoCreateOrConnectWithoutPublicacionInput`
 */
export type ForoCreateOrConnectWithoutPublicacionInput = Prisma.ForoCreateOrConnectWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateWithoutPublicacionInput`
 */
export type UsuarioCreateWithoutPublicacionInput = Prisma.UsuarioCreateWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.UsuarioCreateOrConnectWithoutPublicacionInput`
 */
export type UsuarioCreateOrConnectWithoutPublicacionInput = Prisma.UsuarioCreateOrConnectWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.ForoUpdateWithoutPublicacionInput`
 */
export type ForoUpdateWithoutPublicacionInput = Prisma.ForoUpdateWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.ForoUpsertWithoutPublicacionInput`
 */
export type ForoUpsertWithoutPublicacionInput = Prisma.ForoUpsertWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpdateWithoutPublicacionInput`
 */
export type UsuarioUpdateWithoutPublicacionInput = Prisma.UsuarioUpdateWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.UsuarioUpsertWithoutPublicacionInput`
 */
export type UsuarioUpsertWithoutPublicacionInput = Prisma.UsuarioUpsertWithoutPublicacionInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateWithoutUsuarioInput`
 */
export type AlquilerUpdateWithoutUsuarioInput = Prisma.AlquilerUpdateWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateWithoutUsuarioInput`
 */
export type ReportarUpdateWithoutUsuarioInput = Prisma.ReportarUpdateWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateWithoutUsuarioInput`
 */
export type PublicacionUpdateWithoutUsuarioInput = Prisma.PublicacionUpdateWithoutUsuarioInput

/**
 * @deprecated Renamed to `Prisma.BicicletaUpdateWithoutEstacionInput`
 */
export type BicicletaUpdateWithoutEstacionInput = Prisma.BicicletaUpdateWithoutEstacionInput

/**
 * @deprecated Renamed to `Prisma.AlquilerUpdateWithoutBicicletaInput`
 */
export type AlquilerUpdateWithoutBicicletaInput = Prisma.AlquilerUpdateWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.ReportarUpdateWithoutBicicletaInput`
 */
export type ReportarUpdateWithoutBicicletaInput = Prisma.ReportarUpdateWithoutBicicletaInput

/**
 * @deprecated Renamed to `Prisma.InformacionUpdateWithoutForoInput`
 */
export type InformacionUpdateWithoutForoInput = Prisma.InformacionUpdateWithoutForoInput

/**
 * @deprecated Renamed to `Prisma.PublicacionUpdateWithoutForoInput`
 */
export type PublicacionUpdateWithoutForoInput = Prisma.PublicacionUpdateWithoutForoInput